/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@welldone-software";
exports.ids = ["vendor-chunks/@welldone-software"];
exports.modules = {

/***/ "(ssr)/./node_modules/@welldone-software/why-did-you-render/dist/whyDidYouRender.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@welldone-software/why-did-you-render/dist/whyDidYouRender.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\n * @welldone-software/why-did-you-render 8.0.3\n * MIT Licensed\n * Generated by Vitali Zaidman <vzaidman@gmail.com> (https://github.com/vzaidman)\n * Generated at 2024-06-08\n */\n\n(function (global, factory) {\n   true ? module.exports = factory(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"), __webpack_require__(/*! lodash */ \"(ssr)/./node_modules/lodash/lodash.js\")) :\n  0;\n})(this, (function (React, lodash) { 'use strict';\n\n  function _interopNamespaceDefault(e) {\n    var n = Object.create(null);\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () { return e[k]; }\n          });\n        }\n      });\n    }\n    n.default = e;\n    return Object.freeze(n);\n  }\n\n  var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);\n\n  var wdyrStore = {\n    /* The React object we patch */\n    React: undefined,\n    /* Processed user options for WDYR */\n    options: undefined,\n    /* The original React.createElement function */\n    origCreateElement: undefined,\n    /* The original React.createFactory function */\n    origCreateFactory: undefined,\n    /* The original React.cloneElement function */\n    origCloneElement: undefined,\n    /* A weak map of all React elements to their WDYR patched react elements */\n    componentsMap: new WeakMap(),\n    /* A weak map of props to the owner element that passed them */\n    ownerDataMap: new WeakMap(),\n    /* An array of hooks tracked during one render */\n    hooksPerRender: []\n  };\n\n  function _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n    return n;\n  }\n  function _arrayWithHoles(r) {\n    if (Array.isArray(r)) return r;\n  }\n  function _arrayWithoutHoles(r) {\n    if (Array.isArray(r)) return _arrayLikeToArray(r);\n  }\n  function _assertThisInitialized(e) {\n    if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return e;\n  }\n  function _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n  }\n  function _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n  function _defineProperties(e, r) {\n    for (var t = 0; t < r.length; t++) {\n      var o = r[t];\n      o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n  }\n  function _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), Object.defineProperty(e, \"prototype\", {\n      writable: !1\n    }), e;\n  }\n  function _createForOfIteratorHelper(r, e) {\n    var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (!t) {\n      if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e  ) {\n        t && (r = t);\n        var n = 0,\n          F = function () {};\n        return {\n          s: F,\n          n: function () {\n            return n >= r.length ? {\n              done: !0\n            } : {\n              done: !1,\n              value: r[n++]\n            };\n          },\n          e: function (r) {\n            throw r;\n          },\n          f: F\n        };\n      }\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var o,\n      a = !0,\n      u = !1;\n    return {\n      s: function () {\n        t = t.call(r);\n      },\n      n: function () {\n        var r = t.next();\n        return a = r.done, r;\n      },\n      e: function (r) {\n        u = !0, o = r;\n      },\n      f: function () {\n        try {\n          a || null == t.return || t.return();\n        } finally {\n          if (u) throw o;\n        }\n      }\n    };\n  }\n  function _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n      value: t,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[r] = t, e;\n  }\n  function _get() {\n    return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {\n      var p = _superPropBase(e, t);\n      if (p) {\n        var n = Object.getOwnPropertyDescriptor(p, t);\n        return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;\n      }\n    }, _get.apply(null, arguments);\n  }\n  function _getPrototypeOf(t) {\n    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    }, _getPrototypeOf(t);\n  }\n  function _inherits(t, e) {\n    if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n    t.prototype = Object.create(e && e.prototype, {\n      constructor: {\n        value: t,\n        writable: !0,\n        configurable: !0\n      }\n    }), Object.defineProperty(t, \"prototype\", {\n      writable: !1\n    }), e && _setPrototypeOf(t, e);\n  }\n  function _isNativeReflectConstruct() {\n    try {\n      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function () {\n      return !!t;\n    })();\n  }\n  function _iterableToArray(r) {\n    if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n  }\n  function _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n      var e,\n        n,\n        i,\n        u,\n        a = [],\n        f = !0,\n        o = !1;\n      try {\n        if (i = (t = t.call(r)).next, 0 === l) {\n          if (Object(t) !== t) return;\n          f = !1;\n        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n      } catch (r) {\n        o = !0, n = r;\n      } finally {\n        try {\n          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n        } finally {\n          if (o) throw n;\n        }\n      }\n      return a;\n    }\n  }\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  function ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var o = Object.getOwnPropertySymbols(e);\n      r && (o = o.filter(function (r) {\n        return Object.getOwnPropertyDescriptor(e, r).enumerable;\n      })), t.push.apply(t, o);\n    }\n    return t;\n  }\n  function _objectSpread2(e) {\n    for (var r = 1; r < arguments.length; r++) {\n      var t = null != arguments[r] ? arguments[r] : {};\n      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n        _defineProperty(e, r, t[r]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n      });\n    }\n    return e;\n  }\n  function _possibleConstructorReturn(t, e) {\n    if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n    if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n    return _assertThisInitialized(t);\n  }\n  function _setPrototypeOf(t, e) {\n    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n      return t.__proto__ = e, t;\n    }, _setPrototypeOf(t, e);\n  }\n  function _slicedToArray(r, e) {\n    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n  }\n  function _superPropBase(t, o) {\n    for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)););\n    return t;\n  }\n  function _toConsumableArray(r) {\n    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n  }\n  function _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n      var i = e.call(t, r || \"default\");\n      if (\"object\" != typeof i) return i;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n  }\n  function _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n  }\n  function _typeof(o) {\n    \"@babel/helpers - typeof\";\n\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n      return typeof o;\n    } : function (o) {\n      return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n  }\n  function _unsupportedIterableToArray(r, a) {\n    if (r) {\n      if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n      var t = {}.toString.call(r).slice(8, -1);\n      return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n    }\n  }\n\n  var diffTypes = {\n    'different': 'different',\n    'deepEquals': 'deepEquals',\n    'date': 'date',\n    'regex': 'regex',\n    'reactElement': 'reactElement',\n    'function': 'function',\n    'same': 'same'\n  };\n  var diffTypesDescriptions = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, diffTypes.different, 'different objects'), diffTypes.deepEquals, 'different objects that are equal by value'), diffTypes.date, 'different date objects with the same value'), diffTypes.regex, 'different regular expressions with the same value'), diffTypes.reactElement, 'different React elements (remember that the <jsx/> syntax always produces a *NEW* immutable React element so a component that receives <jsx/> as props always re-renders)'), diffTypes[\"function\"], 'different functions with the same name'), diffTypes.same, 'same objects by ref (===)');\n\n  // copied from packages/shared/ReactSymbols.js in https://github.com/facebook/react\n  var hasSymbol$1 = typeof Symbol === 'function' && Symbol[\"for\"];\n  var REACT_MEMO_TYPE = hasSymbol$1 ? Symbol[\"for\"]('react.memo') : 0xead3;\n  var REACT_FORWARD_REF_TYPE = hasSymbol$1 ? Symbol[\"for\"]('react.forward_ref') : 0xead0;\n  var REACT_STRICT_MODE = 8;\n\n  var hasElementType = typeof Element !== 'undefined';\n\n  // copied from https://github.com/facebook/react/packages/shared/ReactSymbols.js\n  var hasSymbol = typeof Symbol === 'function' && Symbol[\"for\"];\n  var REACT_ELEMENT_TYPE = hasSymbol ? Symbol[\"for\"]('react.element') : 0xeac7;\n  var isReactElement = function isReactElement(object) {\n    return object.$$typeof === REACT_ELEMENT_TYPE;\n  };\n  // end\n\n  function trackDiff(a, b, diffsAccumulator, pathString, diffType) {\n    diffsAccumulator.push({\n      diffType: diffType,\n      pathString: pathString,\n      prevValue: a,\n      nextValue: b\n    });\n    return diffType !== diffTypes.different;\n  }\n  function isGetter(obj, prop) {\n    return !!Object.getOwnPropertyDescriptor(obj, prop)['get'];\n  }\n  var dependenciesMap = new WeakMap();\n  function accumulateDeepEqualDiffs(a, b, diffsAccumulator) {\n    var pathString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n    var _ref = arguments.length > 4 ? arguments[4] : undefined,\n      detailed = _ref.detailed;\n    if (a === b) {\n      if (detailed) {\n        trackDiff(a, b, diffsAccumulator, pathString, diffTypes.same);\n      }\n      return true;\n    }\n    if (!a || !b) {\n      return trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);\n    }\n    if (lodash.isArray(a) && lodash.isArray(b)) {\n      var arrayLength = a.length;\n      if (arrayLength !== b.length) {\n        return trackDiff(_toConsumableArray(a), _toConsumableArray(b), diffsAccumulator, pathString, diffTypes.different);\n      }\n      var arrayItemDiffs = [];\n      var numberOfDeepEqualsItems = 0;\n      for (var i = arrayLength; i--; i > 0) {\n        var diffEquals = accumulateDeepEqualDiffs(a[i], b[i], arrayItemDiffs, \"\".concat(pathString, \"[\").concat(i, \"]\"), {\n          detailed: detailed\n        });\n        if (diffEquals) {\n          numberOfDeepEqualsItems++;\n        }\n      }\n      if (detailed || numberOfDeepEqualsItems !== arrayLength) {\n        diffsAccumulator.push.apply(diffsAccumulator, arrayItemDiffs);\n      }\n      if (numberOfDeepEqualsItems === arrayLength) {\n        return trackDiff(_toConsumableArray(a), _toConsumableArray(b), diffsAccumulator, pathString, diffTypes.deepEquals);\n      }\n      return trackDiff(_toConsumableArray(a), _toConsumableArray(b), diffsAccumulator, pathString, diffTypes.different);\n    }\n    if (lodash.isSet(a) && lodash.isSet(b)) {\n      if (a.size !== b.size) {\n        return trackDiff(new Set(a), new Set(b), diffsAccumulator, pathString, diffTypes.different);\n      }\n      var _iterator = _createForOfIteratorHelper(a),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var valA = _step.value;\n          if (!b.has(valA)) {\n            return trackDiff(new Set(a), new Set(b), diffsAccumulator, pathString, diffTypes.different);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return trackDiff(new Set(a), new Set(b), diffsAccumulator, pathString, diffTypes.deepEquals);\n    }\n    if (lodash.isDate(a) && lodash.isDate(b)) {\n      return a.getTime() === b.getTime() ? trackDiff(new Date(a), new Date(b), diffsAccumulator, pathString, diffTypes.date) : trackDiff(new Date(a), new Date(b), diffsAccumulator, pathString, diffTypes.different);\n    }\n    if (lodash.isRegExp(a) && lodash.isRegExp(b)) {\n      return a.toString() === b.toString() ? trackDiff(a, b, diffsAccumulator, pathString, diffTypes.regex) : trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);\n    }\n    if (hasElementType && a instanceof Element && b instanceof Element) {\n      return trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);\n    }\n    if (isReactElement(a) && isReactElement(b)) {\n      if (a.type !== b.type) {\n        return trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);\n      }\n      var reactElementPropsAreDeepEqual = accumulateDeepEqualDiffs(a.props, b.props, [], \"\".concat(pathString, \".props\"), {\n        detailed: detailed\n      });\n      return reactElementPropsAreDeepEqual ? trackDiff(a, b, diffsAccumulator, pathString, diffTypes.reactElement) : trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);\n    }\n    if (lodash.isFunction(a) && lodash.isFunction(b)) {\n      if (a.name !== b.name) {\n        return trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);\n      }\n      var aDependenciesObj = dependenciesMap.get(a);\n      var bDependenciesObj = dependenciesMap.get(b);\n      if (aDependenciesObj && bDependenciesObj) {\n        var dependenciesAreDeepEqual = accumulateDeepEqualDiffs(aDependenciesObj.deps, bDependenciesObj.deps, diffsAccumulator, \"\".concat(pathString, \":parent-hook-\").concat(aDependenciesObj.hookName, \"-deps\"), {\n          detailed: detailed\n        });\n        return dependenciesAreDeepEqual ? trackDiff(a, b, diffsAccumulator, pathString, diffTypes[\"function\"]) : trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);\n      }\n      return trackDiff(a, b, diffsAccumulator, pathString, diffTypes[\"function\"]);\n    }\n    if (_typeof(a) === 'object' && _typeof(b) === 'object' && Object.getPrototypeOf(a) === Object.getPrototypeOf(b)) {\n      var aKeys = Object.getOwnPropertyNames(a);\n      var bKeys = Object.getOwnPropertyNames(b);\n      var allKeys = lodash.uniq([].concat(_toConsumableArray(aKeys), _toConsumableArray(bKeys)));\n      var clonedA = lodash.isPlainObject(a) ? _objectSpread2({}, a) : a;\n      var clonedB = lodash.isPlainObject(b) ? _objectSpread2({}, b) : b;\n      if (allKeys.length !== aKeys.length || allKeys.length !== bKeys.length) {\n        return trackDiff(clonedA, clonedB, diffsAccumulator, pathString, diffTypes.different);\n      }\n      var relevantKeys = allKeys.filter(function (key) {\n        // do not compare the stack as it differ even though the errors are identical.\n        if (key === 'stack' && lodash.isError(a)) {\n          return false;\n        }\n\n        // getters checking is causing too much problems because of how it's used in js.\n        // not only getters can throw errors, they also cause side effects in many cases.\n        if (isGetter(a, key)) {\n          return false;\n        }\n        return true;\n      });\n      var keysLength = relevantKeys.length;\n      for (var _i = keysLength; _i--; _i > 0) {\n        if (!lodash.has(b, relevantKeys[_i])) {\n          return trackDiff(clonedA, clonedB, diffsAccumulator, pathString, diffTypes.different);\n        }\n      }\n      var objectValuesDiffs = [];\n      var numberOfDeepEqualsObjectValues = 0;\n      for (var _i2 = keysLength; _i2--; _i2 > 0) {\n        var key = relevantKeys[_i2];\n        var deepEquals = accumulateDeepEqualDiffs(a[key], b[key], objectValuesDiffs, \"\".concat(pathString, \".\").concat(key), {\n          detailed: detailed\n        });\n        if (deepEquals) {\n          numberOfDeepEqualsObjectValues++;\n        }\n      }\n      if (detailed || numberOfDeepEqualsObjectValues !== keysLength) {\n        diffsAccumulator.push.apply(diffsAccumulator, objectValuesDiffs);\n      }\n      if (numberOfDeepEqualsObjectValues === keysLength) {\n        return trackDiff(clonedA, clonedB, diffsAccumulator, pathString, diffTypes.deepEquals);\n      }\n      return trackDiff(clonedA, clonedB, diffsAccumulator, pathString, diffTypes.different);\n    }\n    return trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);\n  }\n  function calculateDeepEqualDiffs(a, b, initialPathString) {\n    var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      _ref2$detailed = _ref2.detailed,\n      detailed = _ref2$detailed === void 0 ? false : _ref2$detailed;\n    try {\n      var diffs = [];\n      accumulateDeepEqualDiffs(a, b, diffs, initialPathString, {\n        detailed: detailed\n      });\n      return diffs;\n    } catch (error) {\n      if (error.message && error.message.match(/stack|recursion/i) || error.number === -2146828260) {\n        // warn on circular references, don't crash.\n        // browsers throw different errors name and messages:\n        // chrome/safari: \"RangeError\", \"Maximum call stack size exceeded\"\n        // firefox: \"InternalError\", too much recursion\"\n        // edge: \"Error\", \"Out of stack space\"\n        // eslint-disable-next-line no-console\n        console.warn('Warning: why-did-you-render couldn\\'t handle circular references in props.', error.name, error.message);\n        return false;\n      }\n      throw error;\n    }\n  }\n\n  function printDiff(value1, value2, _ref) {\n    var pathString = _ref.pathString,\n      consoleLog = _ref.consoleLog;\n    var diffs = calculateDeepEqualDiffs(value1, value2, pathString, {\n      detailed: true\n    });\n    var keysLength = Math.max.apply(Math, _toConsumableArray(diffs.map(function (diff) {\n      return diff.pathString.length;\n    }))) + 2;\n    Object.entries(lodash.groupBy(lodash.sortBy(diffs, 'pathString'), 'diffType')).forEach(function (_ref2) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n        diffType = _ref3[0],\n        diffs = _ref3[1];\n      consoleLog(\"%c\".concat(diffTypesDescriptions[diffType], \":\"), 'text-decoration: underline; color: blue;');\n      diffs.forEach(function (diff) {\n        consoleLog(\"\".concat(diff.pathString, \":\").padEnd(keysLength, ' '), diff.prevValue);\n      });\n    });\n  }\n\n  var moreInfoUrl = 'http://bit.ly/wdyr02';\n  var moreInfoHooksUrl = 'http://bit.ly/wdyr3';\n  var inHotReload = false;\n  function shouldLog(reason, Component) {\n    if (inHotReload) {\n      return false;\n    }\n    if (wdyrStore.options.logOnDifferentValues) {\n      return true;\n    }\n    if (Component.whyDidYouRender && Component.whyDidYouRender.logOnDifferentValues) {\n      return true;\n    }\n    var hasDifferentValues = reason.propsDifferences && reason.propsDifferences.some(function (diff) {\n      return diff.diffType === diffTypes.different;\n    }) || reason.stateDifferences && reason.stateDifferences.some(function (diff) {\n      return diff.diffType === diffTypes.different;\n    }) || reason.hookDifferences && reason.hookDifferences.some(function (diff) {\n      return diff.diffType === diffTypes.different;\n    });\n    return !hasDifferentValues;\n  }\n  function logDifference(_ref) {\n    var Component = _ref.Component,\n      displayName = _ref.displayName,\n      hookName = _ref.hookName,\n      prefixMessage = _ref.prefixMessage,\n      diffObjType = _ref.diffObjType,\n      differences = _ref.differences,\n      values = _ref.values;\n    if (differences && differences.length > 0) {\n      wdyrStore.options.consoleLog(_defineProperty({}, displayName, Component), \"\".concat(prefixMessage, \" of \").concat(diffObjType, \" changes:\"));\n      differences.forEach(function (_ref2) {\n        var pathString = _ref2.pathString,\n          diffType = _ref2.diffType,\n          prevValue = _ref2.prevValue,\n          nextValue = _ref2.nextValue;\n        function diffFn() {\n          printDiff(prevValue, nextValue, {\n            pathString: pathString,\n            consoleLog: wdyrStore.options.consoleLog\n          });\n        }\n        wdyrStore.options.consoleGroup(\"%c\".concat(diffObjType === 'hook' ? \"[hook \".concat(hookName, \" result]\") : \"\".concat(diffObjType, \".\"), \"%c\").concat(pathString, \"%c\"), \"color:\".concat(wdyrStore.options.diffNameColor, \";\"), \"color:\".concat(wdyrStore.options.diffPathColor, \";\"), 'color:default;');\n        wdyrStore.options.consoleLog(\"\".concat(diffTypesDescriptions[diffType], \". (more info at \").concat(hookName ? moreInfoHooksUrl : moreInfoUrl, \")\"));\n        wdyrStore.options.consoleLog(_defineProperty({}, \"prev \".concat(pathString), prevValue), '!==', _defineProperty({}, \"next \".concat(pathString), nextValue));\n        if (diffType === diffTypes.deepEquals) {\n          wdyrStore.options.consoleLog({\n            'For detailed diff, right click the following fn, save as global, and run: ': diffFn\n          });\n        }\n        wdyrStore.options.consoleGroupEnd();\n      });\n    } else if (differences) {\n      wdyrStore.options.consoleLog(_defineProperty({}, displayName, Component), \"\".concat(prefixMessage, \" the \").concat(diffObjType, \" object itself changed but its values are all equal.\"), diffObjType === 'props' ? 'This could have been avoided by making the component pure, or by preventing its father from re-rendering.' : 'This usually means this component called setState when no changes in its state actually occurred.', \"More info at \".concat(moreInfoUrl));\n      wdyrStore.options.consoleLog(\"prev \".concat(diffObjType, \":\"), values.prev, ' !== ', values.next, \":next \".concat(diffObjType));\n    }\n  }\n  function defaultNotifier(updateInfo) {\n    var Component = updateInfo.Component,\n      displayName = updateInfo.displayName,\n      hookName = updateInfo.hookName,\n      prevProps = updateInfo.prevProps,\n      prevState = updateInfo.prevState,\n      prevHook = updateInfo.prevHook,\n      nextProps = updateInfo.nextProps,\n      nextState = updateInfo.nextState,\n      nextHook = updateInfo.nextHook,\n      reason = updateInfo.reason;\n    if (!shouldLog(reason, Component, wdyrStore.options)) {\n      return;\n    }\n    wdyrStore.options.consoleGroup(\"%c\".concat(displayName), \"color: \".concat(wdyrStore.options.titleColor, \";\"));\n    var prefixMessage = 'Re-rendered because';\n    if (reason.propsDifferences) {\n      logDifference({\n        Component: Component,\n        displayName: displayName,\n        prefixMessage: prefixMessage,\n        diffObjType: 'props',\n        differences: reason.propsDifferences,\n        values: {\n          prev: prevProps,\n          next: nextProps\n        }\n      });\n      prefixMessage = 'And because';\n    }\n    if (reason.stateDifferences) {\n      logDifference({\n        Component: Component,\n        displayName: displayName,\n        prefixMessage: prefixMessage,\n        diffObjType: 'state',\n        differences: reason.stateDifferences,\n        values: {\n          prev: prevState,\n          next: nextState\n        }\n      });\n    }\n    if (reason.hookDifferences) {\n      logDifference({\n        Component: Component,\n        displayName: displayName,\n        prefixMessage: prefixMessage,\n        diffObjType: 'hook',\n        differences: reason.hookDifferences,\n        values: {\n          prev: prevHook,\n          next: nextHook\n        },\n        hookName: hookName\n      });\n    }\n    if (reason.propsDifferences && reason.ownerDifferences) {\n      var prevOwnerData = wdyrStore.ownerDataMap.get(prevProps);\n      var nextOwnerData = wdyrStore.ownerDataMap.get(nextProps);\n      wdyrStore.options.consoleGroup(\"Rendered by \".concat(nextOwnerData.displayName));\n      var _prefixMessage = 'Re-rendered because';\n      if (reason.ownerDifferences.propsDifferences) {\n        logDifference({\n          Component: nextOwnerData.Component,\n          displayName: nextOwnerData.displayName,\n          prefixMessage: _prefixMessage,\n          diffObjType: 'props',\n          differences: reason.ownerDifferences.propsDifferences,\n          values: {\n            prev: prevOwnerData.props,\n            next: nextOwnerData.props\n          }\n        });\n        _prefixMessage = 'And because';\n      }\n      if (reason.ownerDifferences.stateDifferences) {\n        logDifference({\n          Component: nextOwnerData.Component,\n          displayName: nextOwnerData.displayName,\n          prefixMessage: _prefixMessage,\n          diffObjType: 'state',\n          differences: reason.ownerDifferences.stateDifferences,\n          values: {\n            prev: prevOwnerData.state,\n            next: nextOwnerData.state\n          }\n        });\n      }\n      if (reason.ownerDifferences.hookDifferences) {\n        reason.ownerDifferences.hookDifferences.forEach(function (_ref3, i) {\n          var hookName = _ref3.hookName,\n            differences = _ref3.differences;\n          return logDifference({\n            Component: nextOwnerData.Component,\n            displayName: nextOwnerData.displayName,\n            prefixMessage: _prefixMessage,\n            diffObjType: 'hook',\n            differences: differences,\n            values: {\n              prev: prevOwnerData.hooks[i].result,\n              next: nextOwnerData.hooks[i].result\n            },\n            hookName: hookName\n          });\n        });\n      }\n      wdyrStore.options.consoleGroupEnd();\n    }\n    if (!reason.propsDifferences && !reason.stateDifferences && !reason.hookDifferences) {\n      wdyrStore.options.consoleLog(_defineProperty({}, displayName, Component), 'Re-rendered although props and state objects are the same.', 'This usually means there was a call to this.forceUpdate() inside the component.', \"more info at \".concat(moreInfoUrl));\n    }\n    wdyrStore.options.consoleGroupEnd();\n  }\n  function createDefaultNotifier(hotReloadBufferMs) {\n    if (hotReloadBufferMs) {\n      if (false) {}\n    }\n    return defaultNotifier;\n  }\n\n  var emptyFn = function emptyFn() {};\n  function normalizeOptions() {\n    var userOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var consoleGroup = console.group;\n    var consoleGroupEnd = console.groupEnd;\n    if (userOptions.collapseGroups) {\n      consoleGroup = console.groupCollapsed;\n    } else if (userOptions.onlyLogs) {\n      consoleGroup = console.log;\n      consoleGroupEnd = emptyFn;\n    }\n    var notifier = userOptions.notifier || createDefaultNotifier('hotReloadBufferMs' in userOptions ? userOptions.hotReloadBufferMs : 500);\n    return _objectSpread2({\n      include: null,\n      exclude: null,\n      notifier: notifier,\n      onlyLogs: false,\n      consoleLog: console.log,\n      consoleGroup: consoleGroup,\n      consoleGroupEnd: consoleGroupEnd,\n      logOnDifferentValues: false,\n      logOwnerReasons: true,\n      trackHooks: true,\n      titleColor: '#058',\n      diffNameColor: 'blue',\n      diffPathColor: 'red',\n      trackExtraHooks: [],\n      trackAllPureComponents: false\n    }, userOptions);\n  }\n\n  function getDisplayName(type) {\n    return type.displayName || type.name || type.type && getDisplayName(type.type) || type.render && getDisplayName(type.render) || (lodash.isString(type) ? type : 'Unknown');\n  }\n\n  function getDefaultProps(type) {\n    return type.defaultProps || type.type && getDefaultProps(type.type) || type.render && getDefaultProps(type.render) || undefined;\n  }\n\n  var emptyObject = {};\n  function findObjectsDifferences(userPrevObj, userNextObj) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref$shallow = _ref.shallow,\n      shallow = _ref$shallow === void 0 ? true : _ref$shallow;\n    if (userPrevObj === userNextObj) {\n      return false;\n    }\n    if (!shallow) {\n      return calculateDeepEqualDiffs(userPrevObj, userNextObj);\n    }\n    var prevObj = userPrevObj || emptyObject;\n    var nextObj = userNextObj || emptyObject;\n    var keysOfBothObjects = Object.keys(_objectSpread2(_objectSpread2({}, prevObj), nextObj));\n    return lodash.reduce(keysOfBothObjects, function (result, key) {\n      var deepEqualDiffs = calculateDeepEqualDiffs(prevObj[key], nextObj[key], key);\n      if (deepEqualDiffs) {\n        result = [].concat(_toConsumableArray(result), _toConsumableArray(deepEqualDiffs));\n      }\n      return result;\n    }, []);\n  }\n\n  function getOwnerDifferences(_ref) {\n    var prevOwnerData = _ref.prevOwnerData,\n      nextOwnerData = _ref.nextOwnerData;\n    if (!prevOwnerData || !nextOwnerData) {\n      return false;\n    }\n\n    // in strict mode prevOwnerData might be twice as lengthy because of double renders\n    var prevOwnerDataHooks = prevOwnerData.hooks.length === nextOwnerData.hooks.length * 2 ? prevOwnerData.hooks.slice(prevOwnerData.hooks.length / 2) : prevOwnerData.hooks;\n    var hookDifferences = prevOwnerDataHooks.map(function (_ref2, i) {\n      var hookName = _ref2.hookName,\n        result = _ref2.result;\n      return {\n        hookName: hookName,\n        differences: findObjectsDifferences(result, nextOwnerData.hooks[i].result, {\n          shallow: false\n        })\n      };\n    });\n    return {\n      propsDifferences: findObjectsDifferences(prevOwnerData.props, nextOwnerData.props),\n      stateDifferences: findObjectsDifferences(prevOwnerData.state, nextOwnerData.state),\n      hookDifferences: hookDifferences.length > 0 ? hookDifferences : false\n    };\n  }\n  function getUpdateReason(prevProps, prevState, prevHook, nextProps, nextState, nextHook) {\n    var prevOwnerData = wdyrStore.ownerDataMap.get(prevProps);\n    var nextOwnerData = wdyrStore.ownerDataMap.get(nextProps);\n    return {\n      propsDifferences: findObjectsDifferences(prevProps, nextProps),\n      stateDifferences: findObjectsDifferences(prevState, nextState),\n      hookDifferences: findObjectsDifferences(prevHook, nextHook, {\n        shallow: false\n      }),\n      ownerDifferences: getOwnerDifferences({\n        prevOwnerData: prevOwnerData,\n        nextOwnerData: nextOwnerData\n      })\n    };\n  }\n  function getUpdateInfo(_ref3) {\n    var Component = _ref3.Component,\n      displayName = _ref3.displayName,\n      hookName = _ref3.hookName,\n      prevProps = _ref3.prevProps,\n      prevState = _ref3.prevState,\n      prevHook = _ref3.prevHook,\n      nextProps = _ref3.nextProps,\n      nextState = _ref3.nextState,\n      nextHook = _ref3.nextHook;\n    return {\n      Component: Component,\n      displayName: displayName,\n      hookName: hookName,\n      prevProps: prevProps,\n      prevState: prevState,\n      prevHook: prevHook,\n      nextProps: nextProps,\n      nextState: nextState,\n      nextHook: nextHook,\n      reason: getUpdateReason(prevProps, prevState, prevHook, nextProps, nextState, nextHook)\n    };\n  }\n\n  // copied from https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactTypeOfMode.js\n\n  // based on \"findStrictRoot\" from https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactStrictModeWarnings.js\n  // notice: this is only used for class components. functional components doesn't render twice inside strict mode\n  function checkIfInsideAStrictModeTree(reactComponentInstance) {\n    var reactInternalFiber = reactComponentInstance && (reactComponentInstance._reactInternalFiber || reactComponentInstance._reactInternals);\n    while (reactInternalFiber) {\n      if (reactInternalFiber.mode & REACT_STRICT_MODE) {\n        return true;\n      }\n      reactInternalFiber = reactInternalFiber[\"return\"];\n    }\n    return false;\n  }\n  function isReactClassComponent(Component) {\n    return Component.prototype && !!Component.prototype.isReactComponent;\n  }\n  function isMemoComponent(Component) {\n    return Component.$$typeof === REACT_MEMO_TYPE;\n  }\n  function isForwardRefComponent(Component) {\n    return Component.$$typeof === REACT_FORWARD_REF_TYPE;\n  }\n\n  function shouldInclude(displayName) {\n    return wdyrStore.options.include && wdyrStore.options.include.length > 0 && wdyrStore.options.include.some(function (regex) {\n      return regex.test(displayName);\n    });\n  }\n  function shouldExclude(displayName) {\n    return wdyrStore.options.exclude && wdyrStore.options.exclude.length > 0 && wdyrStore.options.exclude.some(function (regex) {\n      return regex.test(displayName);\n    });\n  }\n  function shouldTrack(Component, _ref) {\n    var isHookChange = _ref.isHookChange;\n    var displayName = getDisplayName(Component);\n    if (shouldExclude(displayName)) {\n      return false;\n    }\n    if (Component.whyDidYouRender === false) {\n      return false;\n    }\n    if (isHookChange && Component.whyDidYouRender && Component.whyDidYouRender.trackHooks === false) {\n      return false;\n    }\n    return !!(Component.whyDidYouRender || wdyrStore.options.trackAllPureComponents && (Component && Component.prototype instanceof wdyrStore.React.PureComponent || isMemoComponent(Component)) || shouldInclude(displayName));\n  }\n\n  function patchClassComponent(ClassComponent, _ref) {\n    var displayName = _ref.displayName,\n      defaultProps = _ref.defaultProps;\n    var WDYRPatchedClassComponent = /*#__PURE__*/function (_ClassComponent) {\n      function WDYRPatchedClassComponent(props, context) {\n        var _this;\n        _classCallCheck(this, WDYRPatchedClassComponent);\n        _this = _callSuper(this, WDYRPatchedClassComponent, [props, context]);\n        _this._WDYR = {\n          renderNumber: 0\n        };\n        var origRender = _get((_getPrototypeOf(WDYRPatchedClassComponent.prototype)), \"render\", _this) || _this.render;\n\n        // this probably means that render is an arrow function or this.render.bind(this) was called on the original class\n        var renderIsABindedFunction = origRender !== ClassComponent.prototype.render;\n        if (renderIsABindedFunction) {\n          _this.render = function () {\n            WDYRPatchedClassComponent.prototype.render.apply(_this);\n            return origRender();\n          };\n        }\n        return _this;\n      }\n      _inherits(WDYRPatchedClassComponent, _ClassComponent);\n      return _createClass(WDYRPatchedClassComponent, [{\n        key: \"render\",\n        value: function render() {\n          this._WDYR.renderNumber++;\n          if (!('isStrictMode' in this._WDYR)) {\n            this._WDYR.isStrictMode = checkIfInsideAStrictModeTree(this);\n          }\n\n          // in strict mode- ignore every other render\n          if (!(this._WDYR.isStrictMode && this._WDYR.renderNumber % 2 === 1)) {\n            if (this._WDYR.prevProps) {\n              var updateInfo = getUpdateInfo({\n                Component: ClassComponent,\n                displayName: displayName,\n                prevProps: this._WDYR.prevProps,\n                prevState: this._WDYR.prevState,\n                nextProps: this.props,\n                nextState: this.state\n              });\n              wdyrStore.options.notifier(updateInfo);\n            }\n            this._WDYR.prevProps = this.props;\n            this._WDYR.prevState = this.state;\n          }\n          return _get(_getPrototypeOf(WDYRPatchedClassComponent.prototype), \"render\", this) ? _get(_getPrototypeOf(WDYRPatchedClassComponent.prototype), \"render\", this).call(this) : null;\n        }\n      }]);\n    }(ClassComponent);\n    try {\n      WDYRPatchedClassComponent.displayName = displayName;\n    } catch (e) {\n      // not crucial if displayName couldn't be set\n    }\n    WDYRPatchedClassComponent.defaultProps = defaultProps;\n    lodash.defaults(WDYRPatchedClassComponent, ClassComponent);\n    return WDYRPatchedClassComponent;\n  }\n\n  var getFunctionalComponentFromStringComponent = function getFunctionalComponentFromStringComponent(componentTypeStr) {\n    return function (props) {\n      return wdyrStore.React.createElement(componentTypeStr, props);\n    };\n  };\n  function patchFunctionalOrStrComponent(FunctionalOrStringComponent, _ref) {\n    var isPure = _ref.isPure,\n      displayName = _ref.displayName,\n      defaultProps = _ref.defaultProps;\n    var FunctionalComponent = typeof FunctionalOrStringComponent === 'string' ? getFunctionalComponentFromStringComponent(FunctionalOrStringComponent) : FunctionalOrStringComponent;\n    function WDYRFunctionalComponent() {\n      var nextProps = arguments[0];\n      var ref = wdyrStore.React.useRef();\n      var prevProps = ref.current;\n      ref.current = nextProps;\n      if (prevProps) {\n        var updateInfo = getUpdateInfo({\n          Component: FunctionalComponent,\n          displayName: displayName,\n          prevProps: prevProps,\n          nextProps: nextProps\n        });\n        var notifiedByHooks = !updateInfo.reason.propsDifferences || isPure && updateInfo.reason.propsDifferences.length === 0;\n        if (!notifiedByHooks) {\n          wdyrStore.options.notifier(updateInfo);\n        }\n      }\n      return FunctionalComponent.apply(void 0, arguments);\n    }\n    try {\n      WDYRFunctionalComponent.displayName = displayName;\n    } catch (e) {\n      // not crucial if displayName couldn't be set\n    }\n    WDYRFunctionalComponent.defaultProps = defaultProps;\n    WDYRFunctionalComponent.ComponentForHooksTracking = FunctionalComponent;\n    lodash.defaults(WDYRFunctionalComponent, FunctionalComponent);\n    return WDYRFunctionalComponent;\n  }\n\n  function patchMemoComponent(MemoComponent, _ref) {\n    var displayName = _ref.displayName,\n      defaultProps = _ref.defaultProps;\n    var InnerMemoComponent = MemoComponent.type;\n    var isInnerMemoComponentAClassComponent = isReactClassComponent(InnerMemoComponent);\n    var isInnerMemoComponentForwardRefs = isForwardRefComponent(InnerMemoComponent);\n    var isInnerMemoComponentAnotherMemoComponent = isMemoComponent(InnerMemoComponent);\n    var WrappedFunctionalComponent = isInnerMemoComponentForwardRefs ? InnerMemoComponent.render : InnerMemoComponent;\n    var PatchedInnerComponent = isInnerMemoComponentAClassComponent ? patchClassComponent(WrappedFunctionalComponent, {\n      displayName: displayName,\n      defaultProps: defaultProps\n    }) : isInnerMemoComponentAnotherMemoComponent ? patchMemoComponent(WrappedFunctionalComponent, {\n      displayName: displayName,\n      defaultProps: defaultProps\n    }) : patchFunctionalOrStrComponent(WrappedFunctionalComponent, {\n      displayName: displayName,\n      isPure: true\n    });\n    try {\n      PatchedInnerComponent.displayName = getDisplayName(WrappedFunctionalComponent);\n    } catch (e) {\n      // not crucial if displayName couldn't be set\n    }\n    PatchedInnerComponent.ComponentForHooksTracking = MemoComponent;\n    lodash.defaults(PatchedInnerComponent, WrappedFunctionalComponent);\n    var WDYRMemoizedFunctionalComponent = wdyrStore.React.memo(isInnerMemoComponentForwardRefs ? wdyrStore.React.forwardRef(PatchedInnerComponent) : PatchedInnerComponent, MemoComponent.compare);\n    try {\n      WDYRMemoizedFunctionalComponent.displayName = displayName;\n    } catch (e) {\n      // not crucial if displayName couldn't be set\n    }\n    WDYRMemoizedFunctionalComponent.defaultProps = defaultProps;\n    lodash.defaults(WDYRMemoizedFunctionalComponent, MemoComponent);\n    return WDYRMemoizedFunctionalComponent;\n  }\n\n  function patchForwardRefComponent(ForwardRefComponent, _ref) {\n    var displayName = _ref.displayName,\n      defaultProps = _ref.defaultProps;\n    var InnerForwardRefComponent = ForwardRefComponent.render;\n    var isInnerComponentMemoized = isMemoComponent(InnerForwardRefComponent);\n    var WrappedFunctionalComponent = isInnerComponentMemoized ? InnerForwardRefComponent.type : InnerForwardRefComponent;\n    var WDYRWrappedByReactForwardRefFunctionalComponent = patchFunctionalOrStrComponent(WrappedFunctionalComponent, {\n      isPure: isInnerComponentMemoized,\n      displayName: displayName\n    });\n    WDYRWrappedByReactForwardRefFunctionalComponent.displayName = getDisplayName(WrappedFunctionalComponent);\n    WDYRWrappedByReactForwardRefFunctionalComponent.ComponentForHooksTracking = WrappedFunctionalComponent;\n    lodash.defaults(WDYRWrappedByReactForwardRefFunctionalComponent, WrappedFunctionalComponent);\n    var WDYRForwardRefFunctionalComponent = wdyrStore.React.forwardRef(isInnerComponentMemoized ? wdyrStore.React.memo(WDYRWrappedByReactForwardRefFunctionalComponent, InnerForwardRefComponent.compare) : WDYRWrappedByReactForwardRefFunctionalComponent);\n    try {\n      WDYRForwardRefFunctionalComponent.displayName = displayName;\n    } catch (e) {\n      // not crucial if displayName couldn't be set\n    }\n    WDYRForwardRefFunctionalComponent.defaultProps = defaultProps;\n    lodash.defaults(WDYRForwardRefFunctionalComponent, ForwardRefComponent);\n    return WDYRForwardRefFunctionalComponent;\n  }\n\n  var initialHookValue = Symbol('initial-hook-value');\n  function trackHookChanges(hookName, _ref, hookResult) {\n    var hookPath = _ref.path;\n    var nextHook = hookPath ? lodash.get(hookResult, hookPath) : hookResult;\n    var renderNumberForTheHook = wdyrStore.React.useRef(true);\n\n    // TODO: improve\n    var isSecondCycleOfRenders = wdyrStore.hooksPerRender[0] && wdyrStore.hooksPerRender[0].renderNumberForTheHook !== renderNumberForTheHook.current;\n    if (isSecondCycleOfRenders) {\n      wdyrStore.hooksPerRender = [];\n    }\n    wdyrStore.hooksPerRender.push({\n      hookName: hookName,\n      result: nextHook,\n      renderNumberForTheHook: renderNumberForTheHook.current\n    });\n    renderNumberForTheHook.current++;\n    var ComponentHookDispatchedFromInstance = wdyrStore.React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && wdyrStore.React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner.current;\n    var prevHookRef = wdyrStore.React.useRef(initialHookValue);\n    if (!ComponentHookDispatchedFromInstance) {\n      return hookResult;\n    }\n    var Component = ComponentHookDispatchedFromInstance.type.ComponentForHooksTracking || ComponentHookDispatchedFromInstance.type;\n    var displayName = getDisplayName(Component);\n    var isShouldTrack = shouldTrack(Component, {\n      isHookChange: true\n    });\n    if (!isShouldTrack) {\n      return hookResult;\n    }\n    var newPrevHookRef = prevHookRef.current;\n    prevHookRef.current = hookResult;\n    if (newPrevHookRef !== initialHookValue) {\n      var notification = getUpdateInfo({\n        Component: Component,\n        displayName: displayName,\n        hookName: hookName,\n        prevHook: hookPath ? lodash.get(newPrevHookRef, hookPath) : newPrevHookRef,\n        nextHook: nextHook\n      });\n      if (notification.reason.hookDifferences) {\n        wdyrStore.options.notifier(notification);\n      }\n    }\n    return hookResult;\n  }\n  function createPatchedComponent(Component, _ref2) {\n    var displayName = _ref2.displayName,\n      defaultProps = _ref2.defaultProps;\n    if (isMemoComponent(Component)) {\n      return patchMemoComponent(Component, {\n        displayName: displayName,\n        defaultProps: defaultProps\n      });\n    }\n    if (isForwardRefComponent(Component)) {\n      return patchForwardRefComponent(Component, {\n        displayName: displayName,\n        defaultProps: defaultProps\n      });\n    }\n    if (isReactClassComponent(Component)) {\n      return patchClassComponent(Component, {\n        displayName: displayName,\n        defaultProps: defaultProps\n      });\n    }\n    return patchFunctionalOrStrComponent(Component, {\n      displayName: displayName,\n      defaultProps: defaultProps,\n      isPure: false\n    });\n  }\n  function getPatchedComponent(Component, _ref3) {\n    var displayName = _ref3.displayName,\n      defaultProps = _ref3.defaultProps;\n    if (wdyrStore.componentsMap.has(Component)) {\n      return wdyrStore.componentsMap.get(Component);\n    }\n    var WDYRPatchedComponent = createPatchedComponent(Component, {\n      displayName: displayName,\n      defaultProps: defaultProps\n    });\n    wdyrStore.componentsMap.set(Component, WDYRPatchedComponent);\n    return WDYRPatchedComponent;\n  }\n  function getIsSupportedComponentType(Comp) {\n    if (!Comp) {\n      return false;\n    }\n    if (isMemoComponent(Comp)) {\n      return getIsSupportedComponentType(Comp.type);\n    }\n    if (isForwardRefComponent(Comp)) {\n      return getIsSupportedComponentType(Comp.render);\n    }\n    if (typeof Comp === 'function') {\n      return true;\n    }\n  }\n  var hooksConfig = {\n    useState: {\n      path: '0'\n    },\n    useReducer: {\n      path: '0'\n    },\n    useContext: undefined,\n    useSyncExternalStore: undefined,\n    useMemo: {\n      dependenciesPath: '1',\n      dontReport: true\n    },\n    useCallback: {\n      dependenciesPath: '1',\n      dontReport: true\n    }\n  };\n  function storeOwnerData(element) {\n    var OwnerInstance = wdyrStore.React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner.current;\n    if (OwnerInstance) {\n      var Component = OwnerInstance.type.ComponentForHooksTracking || OwnerInstance.type;\n      var displayName = getDisplayName(Component);\n      var additionalOwnerData = {};\n      if (wdyrStore.options.getAdditionalOwnerData) {\n        additionalOwnerData = wdyrStore.options.getAdditionalOwnerData(element);\n      }\n      wdyrStore.ownerDataMap.set(element.props, {\n        Component: Component,\n        displayName: displayName,\n        props: OwnerInstance.pendingProps,\n        state: OwnerInstance.stateNode ? OwnerInstance.stateNode.state : null,\n        hooks: wdyrStore.hooksPerRender,\n        additionalOwnerData: additionalOwnerData\n      });\n    }\n  }\n  function resetHooksPerRenderIfNeeded() {\n    // Intercept assignments to ReactCurrentOwner.current to reset hooksPerRender\n    var currentOwner = null;\n    if (wdyrStore.React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) {\n      Object.defineProperty(wdyrStore.React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, 'current', {\n        get: function get() {\n          return currentOwner;\n        },\n        set: function set(value) {\n          currentOwner = value;\n          wdyrStore.hooksPerRender = [];\n        }\n      });\n    }\n  }\n  function trackHooksIfNeeded() {\n    var hooksSupported = !!wdyrStore.React.useState;\n    if (wdyrStore.options.trackHooks && hooksSupported) {\n      var nativeHooks = Object.entries(hooksConfig).map(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n          hookName = _ref5[0],\n          hookTrackingConfig = _ref5[1];\n        return [wdyrStore.React, hookName, hookTrackingConfig];\n      });\n      var hooksToTrack = [].concat(_toConsumableArray(nativeHooks), _toConsumableArray(wdyrStore.options.trackExtraHooks));\n      hooksToTrack.forEach(function (_ref6) {\n        var _ref7 = _slicedToArray(_ref6, 3),\n          hookParent = _ref7[0],\n          hookName = _ref7[1],\n          _ref7$ = _ref7[2],\n          hookTrackingConfig = _ref7$ === void 0 ? {} : _ref7$;\n        var originalHook = hookParent[hookName];\n        var newHookName = hookName[0].toUpperCase() + hookName.slice(1);\n        var newHook = function WhyDidYouRenderReWrittenHook() {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n          var hookResult = originalHook.call.apply(originalHook, [this].concat(args));\n          var dependenciesPath = hookTrackingConfig.dependenciesPath,\n            dontReport = hookTrackingConfig.dontReport;\n          if (dependenciesPath && lodash.isFunction(hookResult)) {\n            dependenciesMap.set(hookResult, {\n              hookName: hookName,\n              deps: lodash.get(args, dependenciesPath)\n            });\n          }\n          if (!dontReport) {\n            trackHookChanges(hookName, hookTrackingConfig, hookResult);\n          }\n          return hookResult;\n        };\n        Object.defineProperty(newHook, 'name', {\n          value: newHookName,\n          writable: false\n        });\n        Object.assign(newHook, {\n          originalHook: originalHook\n        });\n        hookParent[hookName] = newHook;\n      });\n    }\n  }\n  function getWDYRType(origType) {\n    var isShouldTrack = getIsSupportedComponentType(origType) && shouldTrack(origType, {\n      isHookChange: false\n    });\n    if (!isShouldTrack) {\n      return null;\n    }\n    var displayName = origType && origType.whyDidYouRender && origType.whyDidYouRender.customName || getDisplayName(origType);\n    var defaultProps = getDefaultProps(origType);\n    var WDYRPatchedComponent = getPatchedComponent(origType, {\n      displayName: displayName,\n      defaultProps: defaultProps\n    });\n    return WDYRPatchedComponent;\n  }\n  function whyDidYouRender(React, userOptions) {\n    if (React.__IS_WDYR__) {\n      return;\n    }\n    React.__IS_WDYR__ = true;\n    Object.assign(wdyrStore, {\n      React: React,\n      options: normalizeOptions(userOptions),\n      origCreateElement: React.createElement,\n      origCreateFactory: React.createFactory,\n      origCloneElement: React.cloneElement,\n      componentsMap: new WeakMap()\n    });\n    resetHooksPerRenderIfNeeded();\n    React.createElement = function (origType) {\n      var WDYRType = getWDYRType(origType);\n      for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        rest[_key2 - 1] = arguments[_key2];\n      }\n      if (WDYRType) {\n        try {\n          var element = wdyrStore.origCreateElement.apply(React, [WDYRType].concat(rest));\n          if (wdyrStore.options.logOwnerReasons) {\n            storeOwnerData(element);\n          }\n          return element;\n        } catch (e) {\n          wdyrStore.options.consoleLog('whyDidYouRender error. Please file a bug at https://github.com/welldone-software/why-did-you-render/issues.', {\n            errorInfo: {\n              error: e,\n              componentNameOrComponent: origType,\n              rest: rest,\n              options: wdyrStore.options\n            }\n          });\n        }\n      }\n      return wdyrStore.origCreateElement.apply(React, [origType].concat(rest));\n    };\n    Object.assign(React.createElement, wdyrStore.origCreateElement);\n    React.createFactory = function (type) {\n      var factory = React.createElement.bind(null, type);\n      factory.type = type;\n      return factory;\n    };\n    Object.assign(React.createFactory, wdyrStore.origCreateFactory);\n    React.cloneElement = function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      var element = wdyrStore.origCloneElement.apply(React, args);\n      if (wdyrStore.options.logOwnerReasons) {\n        storeOwnerData(element);\n      }\n      return element;\n    };\n    Object.assign(React.cloneElement, wdyrStore.origCloneElement);\n    trackHooksIfNeeded();\n    React.__REVERT_WHY_DID_YOU_RENDER__ = function () {\n      Object.assign(React, {\n        createElement: wdyrStore.origCreateElement,\n        createFactory: wdyrStore.origCreateFactory,\n        cloneElement: wdyrStore.origCloneElement\n      });\n      wdyrStore.componentsMap = null;\n      var hooksToRevert = [].concat(_toConsumableArray(Object.keys(hooksConfig).map(function (hookName) {\n        return [React, hookName];\n      })), _toConsumableArray(wdyrStore.options.trackExtraHooks));\n      hooksToRevert.forEach(function (_ref8) {\n        var _ref9 = _slicedToArray(_ref8, 2),\n          hookParent = _ref9[0],\n          hookName = _ref9[1];\n        if (hookParent[hookName].originalHook) {\n          hookParent[hookName] = hookParent[hookName].originalHook;\n        }\n      });\n      delete React.__REVERT_WHY_DID_YOU_RENDER__;\n      delete React.__IS_WDYR__;\n    };\n    return React;\n  }\n\n  whyDidYouRender.defaultNotifier = defaultNotifier;\n  whyDidYouRender.wdyrStore = wdyrStore;\n  whyDidYouRender.storeOwnerData = storeOwnerData;\n  whyDidYouRender.getWDYRType = getWDYRType;\n  Object.assign(whyDidYouRender, React__namespace);\n\n  return whyDidYouRender;\n\n}));\n//# sourceMappingURL=whyDidYouRender.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHdlbGxkb25lLXNvZnR3YXJlL3doeS1kaWQteW91LXJlbmRlci9kaXN0L3doeURpZFlvdVJlbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLEtBQTRELDRCQUE0QixtQkFBTyxDQUFDLHdHQUFPLEdBQUcsbUJBQU8sQ0FBQyxxREFBUTtBQUM1SCxFQUFFLENBQ3lJO0FBQzNJLENBQUMsb0NBQW9DOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0YsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZLGtFQUFrRTtBQUN4RixRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUcsZ0VBQWdFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSkFBZ0o7O0FBRWhKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRCwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsWUFBWTtBQUM3RztBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxvT0FBb08sdURBQXVELG1CQUFtQjtBQUM5UztBQUNBLHVEQUF1RCxtRUFBbUU7QUFDMUg7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQThHO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBMEUsRUFBRSxFQVMvRTtBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsYUFBYTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGVBQWU7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxlQUFlO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQHdlbGxkb25lLXNvZnR3YXJlL3doeS1kaWQteW91LXJlbmRlci9kaXN0L3doeURpZFlvdVJlbmRlci5qcz9iZjdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHdlbGxkb25lLXNvZnR3YXJlL3doeS1kaWQteW91LXJlbmRlciA4LjAuM1xuICogTUlUIExpY2Vuc2VkXG4gKiBHZW5lcmF0ZWQgYnkgVml0YWxpIFphaWRtYW4gPHZ6YWlkbWFuQGdtYWlsLmNvbT4gKGh0dHBzOi8vZ2l0aHViLmNvbS92emFpZG1hbilcbiAqIEdlbmVyYXRlZCBhdCAyMDI0LTA2LTA4XG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3JlYWN0JyksIHJlcXVpcmUoJ2xvZGFzaCcpKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ3JlYWN0JywgJ2xvZGFzaCddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC53aHlEaWRZb3VSZW5kZXIgPSBmYWN0b3J5KGdsb2JhbC5yZWFjdCwgZ2xvYmFsLmxvZGFzaCkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChSZWFjdCwgbG9kYXNoKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZURlZmF1bHQoZSkge1xuICAgIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoZSkge1xuICAgICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBuLmRlZmF1bHQgPSBlO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xuICB9XG5cbiAgdmFyIFJlYWN0X19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KFJlYWN0KTtcblxuICB2YXIgd2R5clN0b3JlID0ge1xuICAgIC8qIFRoZSBSZWFjdCBvYmplY3Qgd2UgcGF0Y2ggKi9cbiAgICBSZWFjdDogdW5kZWZpbmVkLFxuICAgIC8qIFByb2Nlc3NlZCB1c2VyIG9wdGlvbnMgZm9yIFdEWVIgKi9cbiAgICBvcHRpb25zOiB1bmRlZmluZWQsXG4gICAgLyogVGhlIG9yaWdpbmFsIFJlYWN0LmNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gKi9cbiAgICBvcmlnQ3JlYXRlRWxlbWVudDogdW5kZWZpbmVkLFxuICAgIC8qIFRoZSBvcmlnaW5hbCBSZWFjdC5jcmVhdGVGYWN0b3J5IGZ1bmN0aW9uICovXG4gICAgb3JpZ0NyZWF0ZUZhY3Rvcnk6IHVuZGVmaW5lZCxcbiAgICAvKiBUaGUgb3JpZ2luYWwgUmVhY3QuY2xvbmVFbGVtZW50IGZ1bmN0aW9uICovXG4gICAgb3JpZ0Nsb25lRWxlbWVudDogdW5kZWZpbmVkLFxuICAgIC8qIEEgd2VhayBtYXAgb2YgYWxsIFJlYWN0IGVsZW1lbnRzIHRvIHRoZWlyIFdEWVIgcGF0Y2hlZCByZWFjdCBlbGVtZW50cyAqL1xuICAgIGNvbXBvbmVudHNNYXA6IG5ldyBXZWFrTWFwKCksXG4gICAgLyogQSB3ZWFrIG1hcCBvZiBwcm9wcyB0byB0aGUgb3duZXIgZWxlbWVudCB0aGF0IHBhc3NlZCB0aGVtICovXG4gICAgb3duZXJEYXRhTWFwOiBuZXcgV2Vha01hcCgpLFxuICAgIC8qIEFuIGFycmF5IG9mIGhvb2tzIHRyYWNrZWQgZHVyaW5nIG9uZSByZW5kZXIgKi9cbiAgICBob29rc1BlclJlbmRlcjogW11cbiAgfTtcblxuICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7XG4gICAgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpO1xuICAgIGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdO1xuICAgIHJldHVybiBuO1xuICB9XG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByO1xuICB9XG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyKTtcbiAgfVxuICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKGUpIHtcbiAgICBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7XG4gICAgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTtcbiAgfVxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikge1xuICAgIGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7XG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgICB2YXIgbyA9IHJbdF07XG4gICAgICBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHtcbiAgICByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7XG4gICAgICB3cml0YWJsZTogITFcbiAgICB9KSwgZTtcbiAgfVxuICBmdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihyLCBlKSB7XG4gICAgdmFyIHQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdO1xuICAgIGlmICghdCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocikgfHwgKHQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkocikpIHx8IGUgICkge1xuICAgICAgICB0ICYmIChyID0gdCk7XG4gICAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICBGID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgczogRixcbiAgICAgICAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbiA+PSByLmxlbmd0aCA/IHtcbiAgICAgICAgICAgICAgZG9uZTogITBcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIGRvbmU6ICExLFxuICAgICAgICAgICAgICB2YWx1ZTogcltuKytdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZTogZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHRocm93IHI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmOiBGXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gICAgfVxuICAgIHZhciBvLFxuICAgICAgYSA9ICEwLFxuICAgICAgdSA9ICExO1xuICAgIHJldHVybiB7XG4gICAgICBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHQgPSB0LmNhbGwocik7XG4gICAgICB9LFxuICAgICAgbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgciA9IHQubmV4dCgpO1xuICAgICAgICByZXR1cm4gYSA9IHIuZG9uZSwgcjtcbiAgICAgIH0sXG4gICAgICBlOiBmdW5jdGlvbiAocikge1xuICAgICAgICB1ID0gITAsIG8gPSByO1xuICAgICAgfSxcbiAgICAgIGY6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhIHx8IG51bGwgPT0gdC5yZXR1cm4gfHwgdC5yZXR1cm4oKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAodSkgdGhyb3cgbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHtcbiAgICByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG4gICAgICB2YWx1ZTogdCxcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMFxuICAgIH0pIDogZVtyXSA9IHQsIGU7XG4gIH1cbiAgZnVuY3Rpb24gX2dldCgpIHtcbiAgICByZXR1cm4gX2dldCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFJlZmxlY3QgJiYgUmVmbGVjdC5nZXQgPyBSZWZsZWN0LmdldC5iaW5kKCkgOiBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgICAgdmFyIHAgPSBfc3VwZXJQcm9wQmFzZShlLCB0KTtcbiAgICAgIGlmIChwKSB7XG4gICAgICAgIHZhciBuID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwLCB0KTtcbiAgICAgICAgcmV0dXJuIG4uZ2V0ID8gbi5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IGUgOiByKSA6IG4udmFsdWU7XG4gICAgICB9XG4gICAgfSwgX2dldC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG4gIGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZih0KSB7XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KTtcbiAgICB9LCBfZ2V0UHJvdG90eXBlT2YodCk7XG4gIH1cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHQsIGUpIHtcbiAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlICYmIG51bGwgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IHQsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfVxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJwcm90b3R5cGVcIiwge1xuICAgICAgd3JpdGFibGU6ICExXG4gICAgfSksIGUgJiYgX3NldFByb3RvdHlwZU9mKHQsIGUpO1xuICB9XG4gIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICB9IGNhdGNoICh0KSB7fVxuICAgIHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhIXQ7XG4gICAgfSkoKTtcbiAgfVxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KHIpIHtcbiAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIG51bGwgIT0gcltTeW1ib2wuaXRlcmF0b3JdIHx8IG51bGwgIT0gcltcIkBAaXRlcmF0b3JcIl0pIHJldHVybiBBcnJheS5mcm9tKHIpO1xuICB9XG4gIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7XG4gICAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgICBpZiAobnVsbCAhPSB0KSB7XG4gICAgICB2YXIgZSxcbiAgICAgICAgbixcbiAgICAgICAgaSxcbiAgICAgICAgdSxcbiAgICAgICAgYSA9IFtdLFxuICAgICAgICBmID0gITAsXG4gICAgICAgIG8gPSAhMTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47XG4gICAgICAgICAgZiA9ICExO1xuICAgICAgICB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIG8gPSAhMCwgbiA9IHI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChvKSB0aHJvdyBuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuICBmdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgICB2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgICByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTtcbiAgICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMihlKSB7XG4gICAgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcbiAgICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICAgIHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTtcbiAgICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgZSkge1xuICAgIGlmIChlICYmIChcIm9iamVjdFwiID09IHR5cGVvZiBlIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSkpIHJldHVybiBlO1xuICAgIGlmICh2b2lkIDAgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZCh0KTtcbiAgfVxuICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YodCwgZSkge1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHJldHVybiB0Ll9fcHJvdG9fXyA9IGUsIHQ7XG4gICAgfSwgX3NldFByb3RvdHlwZU9mKHQsIGUpO1xuICB9XG4gIGZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xuICB9XG4gIGZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKHQsIG8pIHtcbiAgICBmb3IgKDsgIXt9Lmhhc093blByb3BlcnR5LmNhbGwodCwgbykgJiYgbnVsbCAhPT0gKHQgPSBfZ2V0UHJvdG90eXBlT2YodCkpOyk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KHIpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXkocikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xuICB9XG4gIGZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICAgIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICAgIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xuICB9XG4gIGZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgICB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjtcbiAgfVxuICBmdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG87XG4gICAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgICB9LCBfdHlwZW9mKG8pO1xuICB9XG4gIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7XG4gICAgaWYgKHIpIHtcbiAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7XG4gICAgICB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpO1xuICAgICAgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRpZmZUeXBlcyA9IHtcbiAgICAnZGlmZmVyZW50JzogJ2RpZmZlcmVudCcsXG4gICAgJ2RlZXBFcXVhbHMnOiAnZGVlcEVxdWFscycsXG4gICAgJ2RhdGUnOiAnZGF0ZScsXG4gICAgJ3JlZ2V4JzogJ3JlZ2V4JyxcbiAgICAncmVhY3RFbGVtZW50JzogJ3JlYWN0RWxlbWVudCcsXG4gICAgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJyxcbiAgICAnc2FtZSc6ICdzYW1lJ1xuICB9O1xuICB2YXIgZGlmZlR5cGVzRGVzY3JpcHRpb25zID0gX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KHt9LCBkaWZmVHlwZXMuZGlmZmVyZW50LCAnZGlmZmVyZW50IG9iamVjdHMnKSwgZGlmZlR5cGVzLmRlZXBFcXVhbHMsICdkaWZmZXJlbnQgb2JqZWN0cyB0aGF0IGFyZSBlcXVhbCBieSB2YWx1ZScpLCBkaWZmVHlwZXMuZGF0ZSwgJ2RpZmZlcmVudCBkYXRlIG9iamVjdHMgd2l0aCB0aGUgc2FtZSB2YWx1ZScpLCBkaWZmVHlwZXMucmVnZXgsICdkaWZmZXJlbnQgcmVndWxhciBleHByZXNzaW9ucyB3aXRoIHRoZSBzYW1lIHZhbHVlJyksIGRpZmZUeXBlcy5yZWFjdEVsZW1lbnQsICdkaWZmZXJlbnQgUmVhY3QgZWxlbWVudHMgKHJlbWVtYmVyIHRoYXQgdGhlIDxqc3gvPiBzeW50YXggYWx3YXlzIHByb2R1Y2VzIGEgKk5FVyogaW1tdXRhYmxlIFJlYWN0IGVsZW1lbnQgc28gYSBjb21wb25lbnQgdGhhdCByZWNlaXZlcyA8anN4Lz4gYXMgcHJvcHMgYWx3YXlzIHJlLXJlbmRlcnMpJyksIGRpZmZUeXBlc1tcImZ1bmN0aW9uXCJdLCAnZGlmZmVyZW50IGZ1bmN0aW9ucyB3aXRoIHRoZSBzYW1lIG5hbWUnKSwgZGlmZlR5cGVzLnNhbWUsICdzYW1lIG9iamVjdHMgYnkgcmVmICg9PT0pJyk7XG5cbiAgLy8gY29waWVkIGZyb20gcGFja2FnZXMvc2hhcmVkL1JlYWN0U3ltYm9scy5qcyBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3RcbiAgdmFyIGhhc1N5bWJvbCQxID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbXCJmb3JcIl07XG4gIHZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wkMSA/IFN5bWJvbFtcImZvclwiXSgncmVhY3QubWVtbycpIDogMHhlYWQzO1xuICB2YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCQxID8gU3ltYm9sW1wiZm9yXCJdKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xuICB2YXIgUkVBQ1RfU1RSSUNUX01PREUgPSA4O1xuXG4gIHZhciBoYXNFbGVtZW50VHlwZSA9IHR5cGVvZiBFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuICAvLyBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcGFja2FnZXMvc2hhcmVkL1JlYWN0U3ltYm9scy5qc1xuICB2YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbXCJmb3JcIl07XG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbXCJmb3JcIl0oJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbiAgdmFyIGlzUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gaXNSZWFjdEVsZW1lbnQob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9O1xuICAvLyBlbmRcblxuICBmdW5jdGlvbiB0cmFja0RpZmYoYSwgYiwgZGlmZnNBY2N1bXVsYXRvciwgcGF0aFN0cmluZywgZGlmZlR5cGUpIHtcbiAgICBkaWZmc0FjY3VtdWxhdG9yLnB1c2goe1xuICAgICAgZGlmZlR5cGU6IGRpZmZUeXBlLFxuICAgICAgcGF0aFN0cmluZzogcGF0aFN0cmluZyxcbiAgICAgIHByZXZWYWx1ZTogYSxcbiAgICAgIG5leHRWYWx1ZTogYlxuICAgIH0pO1xuICAgIHJldHVybiBkaWZmVHlwZSAhPT0gZGlmZlR5cGVzLmRpZmZlcmVudDtcbiAgfVxuICBmdW5jdGlvbiBpc0dldHRlcihvYmosIHByb3ApIHtcbiAgICByZXR1cm4gISFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcClbJ2dldCddO1xuICB9XG4gIHZhciBkZXBlbmRlbmNpZXNNYXAgPSBuZXcgV2Vha01hcCgpO1xuICBmdW5jdGlvbiBhY2N1bXVsYXRlRGVlcEVxdWFsRGlmZnMoYSwgYiwgZGlmZnNBY2N1bXVsYXRvcikge1xuICAgIHZhciBwYXRoU3RyaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAnJztcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogdW5kZWZpbmVkLFxuICAgICAgZGV0YWlsZWQgPSBfcmVmLmRldGFpbGVkO1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICBpZiAoZGV0YWlsZWQpIHtcbiAgICAgICAgdHJhY2tEaWZmKGEsIGIsIGRpZmZzQWNjdW11bGF0b3IsIHBhdGhTdHJpbmcsIGRpZmZUeXBlcy5zYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWEgfHwgIWIpIHtcbiAgICAgIHJldHVybiB0cmFja0RpZmYoYSwgYiwgZGlmZnNBY2N1bXVsYXRvciwgcGF0aFN0cmluZywgZGlmZlR5cGVzLmRpZmZlcmVudCk7XG4gICAgfVxuICAgIGlmIChsb2Rhc2guaXNBcnJheShhKSAmJiBsb2Rhc2guaXNBcnJheShiKSkge1xuICAgICAgdmFyIGFycmF5TGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAoYXJyYXlMZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cmFja0RpZmYoX3RvQ29uc3VtYWJsZUFycmF5KGEpLCBfdG9Db25zdW1hYmxlQXJyYXkoYiksIGRpZmZzQWNjdW11bGF0b3IsIHBhdGhTdHJpbmcsIGRpZmZUeXBlcy5kaWZmZXJlbnQpO1xuICAgICAgfVxuICAgICAgdmFyIGFycmF5SXRlbURpZmZzID0gW107XG4gICAgICB2YXIgbnVtYmVyT2ZEZWVwRXF1YWxzSXRlbXMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IGFycmF5TGVuZ3RoOyBpLS07IGkgPiAwKSB7XG4gICAgICAgIHZhciBkaWZmRXF1YWxzID0gYWNjdW11bGF0ZURlZXBFcXVhbERpZmZzKGFbaV0sIGJbaV0sIGFycmF5SXRlbURpZmZzLCBcIlwiLmNvbmNhdChwYXRoU3RyaW5nLCBcIltcIikuY29uY2F0KGksIFwiXVwiKSwge1xuICAgICAgICAgIGRldGFpbGVkOiBkZXRhaWxlZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRpZmZFcXVhbHMpIHtcbiAgICAgICAgICBudW1iZXJPZkRlZXBFcXVhbHNJdGVtcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGV0YWlsZWQgfHwgbnVtYmVyT2ZEZWVwRXF1YWxzSXRlbXMgIT09IGFycmF5TGVuZ3RoKSB7XG4gICAgICAgIGRpZmZzQWNjdW11bGF0b3IucHVzaC5hcHBseShkaWZmc0FjY3VtdWxhdG9yLCBhcnJheUl0ZW1EaWZmcyk7XG4gICAgICB9XG4gICAgICBpZiAobnVtYmVyT2ZEZWVwRXF1YWxzSXRlbXMgPT09IGFycmF5TGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cmFja0RpZmYoX3RvQ29uc3VtYWJsZUFycmF5KGEpLCBfdG9Db25zdW1hYmxlQXJyYXkoYiksIGRpZmZzQWNjdW11bGF0b3IsIHBhdGhTdHJpbmcsIGRpZmZUeXBlcy5kZWVwRXF1YWxzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFja0RpZmYoX3RvQ29uc3VtYWJsZUFycmF5KGEpLCBfdG9Db25zdW1hYmxlQXJyYXkoYiksIGRpZmZzQWNjdW11bGF0b3IsIHBhdGhTdHJpbmcsIGRpZmZUeXBlcy5kaWZmZXJlbnQpO1xuICAgIH1cbiAgICBpZiAobG9kYXNoLmlzU2V0KGEpICYmIGxvZGFzaC5pc1NldChiKSkge1xuICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiB0cmFja0RpZmYobmV3IFNldChhKSwgbmV3IFNldChiKSwgZGlmZnNBY2N1bXVsYXRvciwgcGF0aFN0cmluZywgZGlmZlR5cGVzLmRpZmZlcmVudCk7XG4gICAgICB9XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoYSksXG4gICAgICAgIF9zdGVwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgdmFsQSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGlmICghYi5oYXModmFsQSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFja0RpZmYobmV3IFNldChhKSwgbmV3IFNldChiKSwgZGlmZnNBY2N1bXVsYXRvciwgcGF0aFN0cmluZywgZGlmZlR5cGVzLmRpZmZlcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhY2tEaWZmKG5ldyBTZXQoYSksIG5ldyBTZXQoYiksIGRpZmZzQWNjdW11bGF0b3IsIHBhdGhTdHJpbmcsIGRpZmZUeXBlcy5kZWVwRXF1YWxzKTtcbiAgICB9XG4gICAgaWYgKGxvZGFzaC5pc0RhdGUoYSkgJiYgbG9kYXNoLmlzRGF0ZShiKSkge1xuICAgICAgcmV0dXJuIGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA/IHRyYWNrRGlmZihuZXcgRGF0ZShhKSwgbmV3IERhdGUoYiksIGRpZmZzQWNjdW11bGF0b3IsIHBhdGhTdHJpbmcsIGRpZmZUeXBlcy5kYXRlKSA6IHRyYWNrRGlmZihuZXcgRGF0ZShhKSwgbmV3IERhdGUoYiksIGRpZmZzQWNjdW11bGF0b3IsIHBhdGhTdHJpbmcsIGRpZmZUeXBlcy5kaWZmZXJlbnQpO1xuICAgIH1cbiAgICBpZiAobG9kYXNoLmlzUmVnRXhwKGEpICYmIGxvZGFzaC5pc1JlZ0V4cChiKSkge1xuICAgICAgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpID8gdHJhY2tEaWZmKGEsIGIsIGRpZmZzQWNjdW11bGF0b3IsIHBhdGhTdHJpbmcsIGRpZmZUeXBlcy5yZWdleCkgOiB0cmFja0RpZmYoYSwgYiwgZGlmZnNBY2N1bXVsYXRvciwgcGF0aFN0cmluZywgZGlmZlR5cGVzLmRpZmZlcmVudCk7XG4gICAgfVxuICAgIGlmIChoYXNFbGVtZW50VHlwZSAmJiBhIGluc3RhbmNlb2YgRWxlbWVudCAmJiBiIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRyYWNrRGlmZihhLCBiLCBkaWZmc0FjY3VtdWxhdG9yLCBwYXRoU3RyaW5nLCBkaWZmVHlwZXMuZGlmZmVyZW50KTtcbiAgICB9XG4gICAgaWYgKGlzUmVhY3RFbGVtZW50KGEpICYmIGlzUmVhY3RFbGVtZW50KGIpKSB7XG4gICAgICBpZiAoYS50eXBlICE9PSBiLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNrRGlmZihhLCBiLCBkaWZmc0FjY3VtdWxhdG9yLCBwYXRoU3RyaW5nLCBkaWZmVHlwZXMuZGlmZmVyZW50KTtcbiAgICAgIH1cbiAgICAgIHZhciByZWFjdEVsZW1lbnRQcm9wc0FyZURlZXBFcXVhbCA9IGFjY3VtdWxhdGVEZWVwRXF1YWxEaWZmcyhhLnByb3BzLCBiLnByb3BzLCBbXSwgXCJcIi5jb25jYXQocGF0aFN0cmluZywgXCIucHJvcHNcIiksIHtcbiAgICAgICAgZGV0YWlsZWQ6IGRldGFpbGVkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZWFjdEVsZW1lbnRQcm9wc0FyZURlZXBFcXVhbCA/IHRyYWNrRGlmZihhLCBiLCBkaWZmc0FjY3VtdWxhdG9yLCBwYXRoU3RyaW5nLCBkaWZmVHlwZXMucmVhY3RFbGVtZW50KSA6IHRyYWNrRGlmZihhLCBiLCBkaWZmc0FjY3VtdWxhdG9yLCBwYXRoU3RyaW5nLCBkaWZmVHlwZXMuZGlmZmVyZW50KTtcbiAgICB9XG4gICAgaWYgKGxvZGFzaC5pc0Z1bmN0aW9uKGEpICYmIGxvZGFzaC5pc0Z1bmN0aW9uKGIpKSB7XG4gICAgICBpZiAoYS5uYW1lICE9PSBiLm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNrRGlmZihhLCBiLCBkaWZmc0FjY3VtdWxhdG9yLCBwYXRoU3RyaW5nLCBkaWZmVHlwZXMuZGlmZmVyZW50KTtcbiAgICAgIH1cbiAgICAgIHZhciBhRGVwZW5kZW5jaWVzT2JqID0gZGVwZW5kZW5jaWVzTWFwLmdldChhKTtcbiAgICAgIHZhciBiRGVwZW5kZW5jaWVzT2JqID0gZGVwZW5kZW5jaWVzTWFwLmdldChiKTtcbiAgICAgIGlmIChhRGVwZW5kZW5jaWVzT2JqICYmIGJEZXBlbmRlbmNpZXNPYmopIHtcbiAgICAgICAgdmFyIGRlcGVuZGVuY2llc0FyZURlZXBFcXVhbCA9IGFjY3VtdWxhdGVEZWVwRXF1YWxEaWZmcyhhRGVwZW5kZW5jaWVzT2JqLmRlcHMsIGJEZXBlbmRlbmNpZXNPYmouZGVwcywgZGlmZnNBY2N1bXVsYXRvciwgXCJcIi5jb25jYXQocGF0aFN0cmluZywgXCI6cGFyZW50LWhvb2stXCIpLmNvbmNhdChhRGVwZW5kZW5jaWVzT2JqLmhvb2tOYW1lLCBcIi1kZXBzXCIpLCB7XG4gICAgICAgICAgZGV0YWlsZWQ6IGRldGFpbGVkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzQXJlRGVlcEVxdWFsID8gdHJhY2tEaWZmKGEsIGIsIGRpZmZzQWNjdW11bGF0b3IsIHBhdGhTdHJpbmcsIGRpZmZUeXBlc1tcImZ1bmN0aW9uXCJdKSA6IHRyYWNrRGlmZihhLCBiLCBkaWZmc0FjY3VtdWxhdG9yLCBwYXRoU3RyaW5nLCBkaWZmVHlwZXMuZGlmZmVyZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFja0RpZmYoYSwgYiwgZGlmZnNBY2N1bXVsYXRvciwgcGF0aFN0cmluZywgZGlmZlR5cGVzW1wiZnVuY3Rpb25cIl0pO1xuICAgIH1cbiAgICBpZiAoX3R5cGVvZihhKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihiKSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGEpID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYikpIHtcbiAgICAgIHZhciBhS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGEpO1xuICAgICAgdmFyIGJLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYik7XG4gICAgICB2YXIgYWxsS2V5cyA9IGxvZGFzaC51bmlxKFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYUtleXMpLCBfdG9Db25zdW1hYmxlQXJyYXkoYktleXMpKSk7XG4gICAgICB2YXIgY2xvbmVkQSA9IGxvZGFzaC5pc1BsYWluT2JqZWN0KGEpID8gX29iamVjdFNwcmVhZDIoe30sIGEpIDogYTtcbiAgICAgIHZhciBjbG9uZWRCID0gbG9kYXNoLmlzUGxhaW5PYmplY3QoYikgPyBfb2JqZWN0U3ByZWFkMih7fSwgYikgOiBiO1xuICAgICAgaWYgKGFsbEtleXMubGVuZ3RoICE9PSBhS2V5cy5sZW5ndGggfHwgYWxsS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJhY2tEaWZmKGNsb25lZEEsIGNsb25lZEIsIGRpZmZzQWNjdW11bGF0b3IsIHBhdGhTdHJpbmcsIGRpZmZUeXBlcy5kaWZmZXJlbnQpO1xuICAgICAgfVxuICAgICAgdmFyIHJlbGV2YW50S2V5cyA9IGFsbEtleXMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLy8gZG8gbm90IGNvbXBhcmUgdGhlIHN0YWNrIGFzIGl0IGRpZmZlciBldmVuIHRob3VnaCB0aGUgZXJyb3JzIGFyZSBpZGVudGljYWwuXG4gICAgICAgIGlmIChrZXkgPT09ICdzdGFjaycgJiYgbG9kYXNoLmlzRXJyb3IoYSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXR0ZXJzIGNoZWNraW5nIGlzIGNhdXNpbmcgdG9vIG11Y2ggcHJvYmxlbXMgYmVjYXVzZSBvZiBob3cgaXQncyB1c2VkIGluIGpzLlxuICAgICAgICAvLyBub3Qgb25seSBnZXR0ZXJzIGNhbiB0aHJvdyBlcnJvcnMsIHRoZXkgYWxzbyBjYXVzZSBzaWRlIGVmZmVjdHMgaW4gbWFueSBjYXNlcy5cbiAgICAgICAgaWYgKGlzR2V0dGVyKGEsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICAgIHZhciBrZXlzTGVuZ3RoID0gcmVsZXZhbnRLZXlzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIF9pID0ga2V5c0xlbmd0aDsgX2ktLTsgX2kgPiAwKSB7XG4gICAgICAgIGlmICghbG9kYXNoLmhhcyhiLCByZWxldmFudEtleXNbX2ldKSkge1xuICAgICAgICAgIHJldHVybiB0cmFja0RpZmYoY2xvbmVkQSwgY2xvbmVkQiwgZGlmZnNBY2N1bXVsYXRvciwgcGF0aFN0cmluZywgZGlmZlR5cGVzLmRpZmZlcmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBvYmplY3RWYWx1ZXNEaWZmcyA9IFtdO1xuICAgICAgdmFyIG51bWJlck9mRGVlcEVxdWFsc09iamVjdFZhbHVlcyA9IDA7XG4gICAgICBmb3IgKHZhciBfaTIgPSBrZXlzTGVuZ3RoOyBfaTItLTsgX2kyID4gMCkge1xuICAgICAgICB2YXIga2V5ID0gcmVsZXZhbnRLZXlzW19pMl07XG4gICAgICAgIHZhciBkZWVwRXF1YWxzID0gYWNjdW11bGF0ZURlZXBFcXVhbERpZmZzKGFba2V5XSwgYltrZXldLCBvYmplY3RWYWx1ZXNEaWZmcywgXCJcIi5jb25jYXQocGF0aFN0cmluZywgXCIuXCIpLmNvbmNhdChrZXkpLCB7XG4gICAgICAgICAgZGV0YWlsZWQ6IGRldGFpbGVkXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGVlcEVxdWFscykge1xuICAgICAgICAgIG51bWJlck9mRGVlcEVxdWFsc09iamVjdFZhbHVlcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGV0YWlsZWQgfHwgbnVtYmVyT2ZEZWVwRXF1YWxzT2JqZWN0VmFsdWVzICE9PSBrZXlzTGVuZ3RoKSB7XG4gICAgICAgIGRpZmZzQWNjdW11bGF0b3IucHVzaC5hcHBseShkaWZmc0FjY3VtdWxhdG9yLCBvYmplY3RWYWx1ZXNEaWZmcyk7XG4gICAgICB9XG4gICAgICBpZiAobnVtYmVyT2ZEZWVwRXF1YWxzT2JqZWN0VmFsdWVzID09PSBrZXlzTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cmFja0RpZmYoY2xvbmVkQSwgY2xvbmVkQiwgZGlmZnNBY2N1bXVsYXRvciwgcGF0aFN0cmluZywgZGlmZlR5cGVzLmRlZXBFcXVhbHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYWNrRGlmZihjbG9uZWRBLCBjbG9uZWRCLCBkaWZmc0FjY3VtdWxhdG9yLCBwYXRoU3RyaW5nLCBkaWZmVHlwZXMuZGlmZmVyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYWNrRGlmZihhLCBiLCBkaWZmc0FjY3VtdWxhdG9yLCBwYXRoU3RyaW5nLCBkaWZmVHlwZXMuZGlmZmVyZW50KTtcbiAgfVxuICBmdW5jdGlvbiBjYWxjdWxhdGVEZWVwRXF1YWxEaWZmcyhhLCBiLCBpbml0aWFsUGF0aFN0cmluZykge1xuICAgIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge30sXG4gICAgICBfcmVmMiRkZXRhaWxlZCA9IF9yZWYyLmRldGFpbGVkLFxuICAgICAgZGV0YWlsZWQgPSBfcmVmMiRkZXRhaWxlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMiRkZXRhaWxlZDtcbiAgICB0cnkge1xuICAgICAgdmFyIGRpZmZzID0gW107XG4gICAgICBhY2N1bXVsYXRlRGVlcEVxdWFsRGlmZnMoYSwgYiwgZGlmZnMsIGluaXRpYWxQYXRoU3RyaW5nLCB7XG4gICAgICAgIGRldGFpbGVkOiBkZXRhaWxlZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGlmZnM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlICYmIGVycm9yLm1lc3NhZ2UubWF0Y2goL3N0YWNrfHJlY3Vyc2lvbi9pKSB8fCBlcnJvci5udW1iZXIgPT09IC0yMTQ2ODI4MjYwKSB7XG4gICAgICAgIC8vIHdhcm4gb24gY2lyY3VsYXIgcmVmZXJlbmNlcywgZG9uJ3QgY3Jhc2guXG4gICAgICAgIC8vIGJyb3dzZXJzIHRocm93IGRpZmZlcmVudCBlcnJvcnMgbmFtZSBhbmQgbWVzc2FnZXM6XG4gICAgICAgIC8vIGNocm9tZS9zYWZhcmk6IFwiUmFuZ2VFcnJvclwiLCBcIk1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCJcbiAgICAgICAgLy8gZmlyZWZveDogXCJJbnRlcm5hbEVycm9yXCIsIHRvbyBtdWNoIHJlY3Vyc2lvblwiXG4gICAgICAgIC8vIGVkZ2U6IFwiRXJyb3JcIiwgXCJPdXQgb2Ygc3RhY2sgc3BhY2VcIlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IHdoeS1kaWQteW91LXJlbmRlciBjb3VsZG5cXCd0IGhhbmRsZSBjaXJjdWxhciByZWZlcmVuY2VzIGluIHByb3BzLicsIGVycm9yLm5hbWUsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmludERpZmYodmFsdWUxLCB2YWx1ZTIsIF9yZWYpIHtcbiAgICB2YXIgcGF0aFN0cmluZyA9IF9yZWYucGF0aFN0cmluZyxcbiAgICAgIGNvbnNvbGVMb2cgPSBfcmVmLmNvbnNvbGVMb2c7XG4gICAgdmFyIGRpZmZzID0gY2FsY3VsYXRlRGVlcEVxdWFsRGlmZnModmFsdWUxLCB2YWx1ZTIsIHBhdGhTdHJpbmcsIHtcbiAgICAgIGRldGFpbGVkOiB0cnVlXG4gICAgfSk7XG4gICAgdmFyIGtleXNMZW5ndGggPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoZGlmZnMubWFwKGZ1bmN0aW9uIChkaWZmKSB7XG4gICAgICByZXR1cm4gZGlmZi5wYXRoU3RyaW5nLmxlbmd0aDtcbiAgICB9KSkpICsgMjtcbiAgICBPYmplY3QuZW50cmllcyhsb2Rhc2guZ3JvdXBCeShsb2Rhc2guc29ydEJ5KGRpZmZzLCAncGF0aFN0cmluZycpLCAnZGlmZlR5cGUnKSkuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgIHZhciBfcmVmMyA9IF9zbGljZWRUb0FycmF5KF9yZWYyLCAyKSxcbiAgICAgICAgZGlmZlR5cGUgPSBfcmVmM1swXSxcbiAgICAgICAgZGlmZnMgPSBfcmVmM1sxXTtcbiAgICAgIGNvbnNvbGVMb2coXCIlY1wiLmNvbmNhdChkaWZmVHlwZXNEZXNjcmlwdGlvbnNbZGlmZlR5cGVdLCBcIjpcIiksICd0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTsgY29sb3I6IGJsdWU7Jyk7XG4gICAgICBkaWZmcy5mb3JFYWNoKGZ1bmN0aW9uIChkaWZmKSB7XG4gICAgICAgIGNvbnNvbGVMb2coXCJcIi5jb25jYXQoZGlmZi5wYXRoU3RyaW5nLCBcIjpcIikucGFkRW5kKGtleXNMZW5ndGgsICcgJyksIGRpZmYucHJldlZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIG1vcmVJbmZvVXJsID0gJ2h0dHA6Ly9iaXQubHkvd2R5cjAyJztcbiAgdmFyIG1vcmVJbmZvSG9va3NVcmwgPSAnaHR0cDovL2JpdC5seS93ZHlyMyc7XG4gIHZhciBpbkhvdFJlbG9hZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBzaG91bGRMb2cocmVhc29uLCBDb21wb25lbnQpIHtcbiAgICBpZiAoaW5Ib3RSZWxvYWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHdkeXJTdG9yZS5vcHRpb25zLmxvZ09uRGlmZmVyZW50VmFsdWVzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKENvbXBvbmVudC53aHlEaWRZb3VSZW5kZXIgJiYgQ29tcG9uZW50LndoeURpZFlvdVJlbmRlci5sb2dPbkRpZmZlcmVudFZhbHVlcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBoYXNEaWZmZXJlbnRWYWx1ZXMgPSByZWFzb24ucHJvcHNEaWZmZXJlbmNlcyAmJiByZWFzb24ucHJvcHNEaWZmZXJlbmNlcy5zb21lKGZ1bmN0aW9uIChkaWZmKSB7XG4gICAgICByZXR1cm4gZGlmZi5kaWZmVHlwZSA9PT0gZGlmZlR5cGVzLmRpZmZlcmVudDtcbiAgICB9KSB8fCByZWFzb24uc3RhdGVEaWZmZXJlbmNlcyAmJiByZWFzb24uc3RhdGVEaWZmZXJlbmNlcy5zb21lKGZ1bmN0aW9uIChkaWZmKSB7XG4gICAgICByZXR1cm4gZGlmZi5kaWZmVHlwZSA9PT0gZGlmZlR5cGVzLmRpZmZlcmVudDtcbiAgICB9KSB8fCByZWFzb24uaG9va0RpZmZlcmVuY2VzICYmIHJlYXNvbi5ob29rRGlmZmVyZW5jZXMuc29tZShmdW5jdGlvbiAoZGlmZikge1xuICAgICAgcmV0dXJuIGRpZmYuZGlmZlR5cGUgPT09IGRpZmZUeXBlcy5kaWZmZXJlbnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuICFoYXNEaWZmZXJlbnRWYWx1ZXM7XG4gIH1cbiAgZnVuY3Rpb24gbG9nRGlmZmVyZW5jZShfcmVmKSB7XG4gICAgdmFyIENvbXBvbmVudCA9IF9yZWYuQ29tcG9uZW50LFxuICAgICAgZGlzcGxheU5hbWUgPSBfcmVmLmRpc3BsYXlOYW1lLFxuICAgICAgaG9va05hbWUgPSBfcmVmLmhvb2tOYW1lLFxuICAgICAgcHJlZml4TWVzc2FnZSA9IF9yZWYucHJlZml4TWVzc2FnZSxcbiAgICAgIGRpZmZPYmpUeXBlID0gX3JlZi5kaWZmT2JqVHlwZSxcbiAgICAgIGRpZmZlcmVuY2VzID0gX3JlZi5kaWZmZXJlbmNlcyxcbiAgICAgIHZhbHVlcyA9IF9yZWYudmFsdWVzO1xuICAgIGlmIChkaWZmZXJlbmNlcyAmJiBkaWZmZXJlbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICB3ZHlyU3RvcmUub3B0aW9ucy5jb25zb2xlTG9nKF9kZWZpbmVQcm9wZXJ0eSh7fSwgZGlzcGxheU5hbWUsIENvbXBvbmVudCksIFwiXCIuY29uY2F0KHByZWZpeE1lc3NhZ2UsIFwiIG9mIFwiKS5jb25jYXQoZGlmZk9ialR5cGUsIFwiIGNoYW5nZXM6XCIpKTtcbiAgICAgIGRpZmZlcmVuY2VzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgIHZhciBwYXRoU3RyaW5nID0gX3JlZjIucGF0aFN0cmluZyxcbiAgICAgICAgICBkaWZmVHlwZSA9IF9yZWYyLmRpZmZUeXBlLFxuICAgICAgICAgIHByZXZWYWx1ZSA9IF9yZWYyLnByZXZWYWx1ZSxcbiAgICAgICAgICBuZXh0VmFsdWUgPSBfcmVmMi5uZXh0VmFsdWU7XG4gICAgICAgIGZ1bmN0aW9uIGRpZmZGbigpIHtcbiAgICAgICAgICBwcmludERpZmYocHJldlZhbHVlLCBuZXh0VmFsdWUsIHtcbiAgICAgICAgICAgIHBhdGhTdHJpbmc6IHBhdGhTdHJpbmcsXG4gICAgICAgICAgICBjb25zb2xlTG9nOiB3ZHlyU3RvcmUub3B0aW9ucy5jb25zb2xlTG9nXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgd2R5clN0b3JlLm9wdGlvbnMuY29uc29sZUdyb3VwKFwiJWNcIi5jb25jYXQoZGlmZk9ialR5cGUgPT09ICdob29rJyA/IFwiW2hvb2sgXCIuY29uY2F0KGhvb2tOYW1lLCBcIiByZXN1bHRdXCIpIDogXCJcIi5jb25jYXQoZGlmZk9ialR5cGUsIFwiLlwiKSwgXCIlY1wiKS5jb25jYXQocGF0aFN0cmluZywgXCIlY1wiKSwgXCJjb2xvcjpcIi5jb25jYXQod2R5clN0b3JlLm9wdGlvbnMuZGlmZk5hbWVDb2xvciwgXCI7XCIpLCBcImNvbG9yOlwiLmNvbmNhdCh3ZHlyU3RvcmUub3B0aW9ucy5kaWZmUGF0aENvbG9yLCBcIjtcIiksICdjb2xvcjpkZWZhdWx0OycpO1xuICAgICAgICB3ZHlyU3RvcmUub3B0aW9ucy5jb25zb2xlTG9nKFwiXCIuY29uY2F0KGRpZmZUeXBlc0Rlc2NyaXB0aW9uc1tkaWZmVHlwZV0sIFwiLiAobW9yZSBpbmZvIGF0IFwiKS5jb25jYXQoaG9va05hbWUgPyBtb3JlSW5mb0hvb2tzVXJsIDogbW9yZUluZm9VcmwsIFwiKVwiKSk7XG4gICAgICAgIHdkeXJTdG9yZS5vcHRpb25zLmNvbnNvbGVMb2coX2RlZmluZVByb3BlcnR5KHt9LCBcInByZXYgXCIuY29uY2F0KHBhdGhTdHJpbmcpLCBwcmV2VmFsdWUpLCAnIT09JywgX2RlZmluZVByb3BlcnR5KHt9LCBcIm5leHQgXCIuY29uY2F0KHBhdGhTdHJpbmcpLCBuZXh0VmFsdWUpKTtcbiAgICAgICAgaWYgKGRpZmZUeXBlID09PSBkaWZmVHlwZXMuZGVlcEVxdWFscykge1xuICAgICAgICAgIHdkeXJTdG9yZS5vcHRpb25zLmNvbnNvbGVMb2coe1xuICAgICAgICAgICAgJ0ZvciBkZXRhaWxlZCBkaWZmLCByaWdodCBjbGljayB0aGUgZm9sbG93aW5nIGZuLCBzYXZlIGFzIGdsb2JhbCwgYW5kIHJ1bjogJzogZGlmZkZuXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgd2R5clN0b3JlLm9wdGlvbnMuY29uc29sZUdyb3VwRW5kKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGRpZmZlcmVuY2VzKSB7XG4gICAgICB3ZHlyU3RvcmUub3B0aW9ucy5jb25zb2xlTG9nKF9kZWZpbmVQcm9wZXJ0eSh7fSwgZGlzcGxheU5hbWUsIENvbXBvbmVudCksIFwiXCIuY29uY2F0KHByZWZpeE1lc3NhZ2UsIFwiIHRoZSBcIikuY29uY2F0KGRpZmZPYmpUeXBlLCBcIiBvYmplY3QgaXRzZWxmIGNoYW5nZWQgYnV0IGl0cyB2YWx1ZXMgYXJlIGFsbCBlcXVhbC5cIiksIGRpZmZPYmpUeXBlID09PSAncHJvcHMnID8gJ1RoaXMgY291bGQgaGF2ZSBiZWVuIGF2b2lkZWQgYnkgbWFraW5nIHRoZSBjb21wb25lbnQgcHVyZSwgb3IgYnkgcHJldmVudGluZyBpdHMgZmF0aGVyIGZyb20gcmUtcmVuZGVyaW5nLicgOiAnVGhpcyB1c3VhbGx5IG1lYW5zIHRoaXMgY29tcG9uZW50IGNhbGxlZCBzZXRTdGF0ZSB3aGVuIG5vIGNoYW5nZXMgaW4gaXRzIHN0YXRlIGFjdHVhbGx5IG9jY3VycmVkLicsIFwiTW9yZSBpbmZvIGF0IFwiLmNvbmNhdChtb3JlSW5mb1VybCkpO1xuICAgICAgd2R5clN0b3JlLm9wdGlvbnMuY29uc29sZUxvZyhcInByZXYgXCIuY29uY2F0KGRpZmZPYmpUeXBlLCBcIjpcIiksIHZhbHVlcy5wcmV2LCAnICE9PSAnLCB2YWx1ZXMubmV4dCwgXCI6bmV4dCBcIi5jb25jYXQoZGlmZk9ialR5cGUpKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGVmYXVsdE5vdGlmaWVyKHVwZGF0ZUluZm8pIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdXBkYXRlSW5mby5Db21wb25lbnQsXG4gICAgICBkaXNwbGF5TmFtZSA9IHVwZGF0ZUluZm8uZGlzcGxheU5hbWUsXG4gICAgICBob29rTmFtZSA9IHVwZGF0ZUluZm8uaG9va05hbWUsXG4gICAgICBwcmV2UHJvcHMgPSB1cGRhdGVJbmZvLnByZXZQcm9wcyxcbiAgICAgIHByZXZTdGF0ZSA9IHVwZGF0ZUluZm8ucHJldlN0YXRlLFxuICAgICAgcHJldkhvb2sgPSB1cGRhdGVJbmZvLnByZXZIb29rLFxuICAgICAgbmV4dFByb3BzID0gdXBkYXRlSW5mby5uZXh0UHJvcHMsXG4gICAgICBuZXh0U3RhdGUgPSB1cGRhdGVJbmZvLm5leHRTdGF0ZSxcbiAgICAgIG5leHRIb29rID0gdXBkYXRlSW5mby5uZXh0SG9vayxcbiAgICAgIHJlYXNvbiA9IHVwZGF0ZUluZm8ucmVhc29uO1xuICAgIGlmICghc2hvdWxkTG9nKHJlYXNvbiwgQ29tcG9uZW50LCB3ZHlyU3RvcmUub3B0aW9ucykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2R5clN0b3JlLm9wdGlvbnMuY29uc29sZUdyb3VwKFwiJWNcIi5jb25jYXQoZGlzcGxheU5hbWUpLCBcImNvbG9yOiBcIi5jb25jYXQod2R5clN0b3JlLm9wdGlvbnMudGl0bGVDb2xvciwgXCI7XCIpKTtcbiAgICB2YXIgcHJlZml4TWVzc2FnZSA9ICdSZS1yZW5kZXJlZCBiZWNhdXNlJztcbiAgICBpZiAocmVhc29uLnByb3BzRGlmZmVyZW5jZXMpIHtcbiAgICAgIGxvZ0RpZmZlcmVuY2Uoe1xuICAgICAgICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICBwcmVmaXhNZXNzYWdlOiBwcmVmaXhNZXNzYWdlLFxuICAgICAgICBkaWZmT2JqVHlwZTogJ3Byb3BzJyxcbiAgICAgICAgZGlmZmVyZW5jZXM6IHJlYXNvbi5wcm9wc0RpZmZlcmVuY2VzLFxuICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICBwcmV2OiBwcmV2UHJvcHMsXG4gICAgICAgICAgbmV4dDogbmV4dFByb3BzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcHJlZml4TWVzc2FnZSA9ICdBbmQgYmVjYXVzZSc7XG4gICAgfVxuICAgIGlmIChyZWFzb24uc3RhdGVEaWZmZXJlbmNlcykge1xuICAgICAgbG9nRGlmZmVyZW5jZSh7XG4gICAgICAgIENvbXBvbmVudDogQ29tcG9uZW50LFxuICAgICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICAgIHByZWZpeE1lc3NhZ2U6IHByZWZpeE1lc3NhZ2UsXG4gICAgICAgIGRpZmZPYmpUeXBlOiAnc3RhdGUnLFxuICAgICAgICBkaWZmZXJlbmNlczogcmVhc29uLnN0YXRlRGlmZmVyZW5jZXMsXG4gICAgICAgIHZhbHVlczoge1xuICAgICAgICAgIHByZXY6IHByZXZTdGF0ZSxcbiAgICAgICAgICBuZXh0OiBuZXh0U3RhdGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChyZWFzb24uaG9va0RpZmZlcmVuY2VzKSB7XG4gICAgICBsb2dEaWZmZXJlbmNlKHtcbiAgICAgICAgQ29tcG9uZW50OiBDb21wb25lbnQsXG4gICAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgICAgcHJlZml4TWVzc2FnZTogcHJlZml4TWVzc2FnZSxcbiAgICAgICAgZGlmZk9ialR5cGU6ICdob29rJyxcbiAgICAgICAgZGlmZmVyZW5jZXM6IHJlYXNvbi5ob29rRGlmZmVyZW5jZXMsXG4gICAgICAgIHZhbHVlczoge1xuICAgICAgICAgIHByZXY6IHByZXZIb29rLFxuICAgICAgICAgIG5leHQ6IG5leHRIb29rXG4gICAgICAgIH0sXG4gICAgICAgIGhvb2tOYW1lOiBob29rTmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChyZWFzb24ucHJvcHNEaWZmZXJlbmNlcyAmJiByZWFzb24ub3duZXJEaWZmZXJlbmNlcykge1xuICAgICAgdmFyIHByZXZPd25lckRhdGEgPSB3ZHlyU3RvcmUub3duZXJEYXRhTWFwLmdldChwcmV2UHJvcHMpO1xuICAgICAgdmFyIG5leHRPd25lckRhdGEgPSB3ZHlyU3RvcmUub3duZXJEYXRhTWFwLmdldChuZXh0UHJvcHMpO1xuICAgICAgd2R5clN0b3JlLm9wdGlvbnMuY29uc29sZUdyb3VwKFwiUmVuZGVyZWQgYnkgXCIuY29uY2F0KG5leHRPd25lckRhdGEuZGlzcGxheU5hbWUpKTtcbiAgICAgIHZhciBfcHJlZml4TWVzc2FnZSA9ICdSZS1yZW5kZXJlZCBiZWNhdXNlJztcbiAgICAgIGlmIChyZWFzb24ub3duZXJEaWZmZXJlbmNlcy5wcm9wc0RpZmZlcmVuY2VzKSB7XG4gICAgICAgIGxvZ0RpZmZlcmVuY2Uoe1xuICAgICAgICAgIENvbXBvbmVudDogbmV4dE93bmVyRGF0YS5Db21wb25lbnQsXG4gICAgICAgICAgZGlzcGxheU5hbWU6IG5leHRPd25lckRhdGEuZGlzcGxheU5hbWUsXG4gICAgICAgICAgcHJlZml4TWVzc2FnZTogX3ByZWZpeE1lc3NhZ2UsXG4gICAgICAgICAgZGlmZk9ialR5cGU6ICdwcm9wcycsXG4gICAgICAgICAgZGlmZmVyZW5jZXM6IHJlYXNvbi5vd25lckRpZmZlcmVuY2VzLnByb3BzRGlmZmVyZW5jZXMsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBwcmV2OiBwcmV2T3duZXJEYXRhLnByb3BzLFxuICAgICAgICAgICAgbmV4dDogbmV4dE93bmVyRGF0YS5wcm9wc1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF9wcmVmaXhNZXNzYWdlID0gJ0FuZCBiZWNhdXNlJztcbiAgICAgIH1cbiAgICAgIGlmIChyZWFzb24ub3duZXJEaWZmZXJlbmNlcy5zdGF0ZURpZmZlcmVuY2VzKSB7XG4gICAgICAgIGxvZ0RpZmZlcmVuY2Uoe1xuICAgICAgICAgIENvbXBvbmVudDogbmV4dE93bmVyRGF0YS5Db21wb25lbnQsXG4gICAgICAgICAgZGlzcGxheU5hbWU6IG5leHRPd25lckRhdGEuZGlzcGxheU5hbWUsXG4gICAgICAgICAgcHJlZml4TWVzc2FnZTogX3ByZWZpeE1lc3NhZ2UsXG4gICAgICAgICAgZGlmZk9ialR5cGU6ICdzdGF0ZScsXG4gICAgICAgICAgZGlmZmVyZW5jZXM6IHJlYXNvbi5vd25lckRpZmZlcmVuY2VzLnN0YXRlRGlmZmVyZW5jZXMsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBwcmV2OiBwcmV2T3duZXJEYXRhLnN0YXRlLFxuICAgICAgICAgICAgbmV4dDogbmV4dE93bmVyRGF0YS5zdGF0ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAocmVhc29uLm93bmVyRGlmZmVyZW5jZXMuaG9va0RpZmZlcmVuY2VzKSB7XG4gICAgICAgIHJlYXNvbi5vd25lckRpZmZlcmVuY2VzLmhvb2tEaWZmZXJlbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMywgaSkge1xuICAgICAgICAgIHZhciBob29rTmFtZSA9IF9yZWYzLmhvb2tOYW1lLFxuICAgICAgICAgICAgZGlmZmVyZW5jZXMgPSBfcmVmMy5kaWZmZXJlbmNlcztcbiAgICAgICAgICByZXR1cm4gbG9nRGlmZmVyZW5jZSh7XG4gICAgICAgICAgICBDb21wb25lbnQ6IG5leHRPd25lckRhdGEuQ29tcG9uZW50LFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6IG5leHRPd25lckRhdGEuZGlzcGxheU5hbWUsXG4gICAgICAgICAgICBwcmVmaXhNZXNzYWdlOiBfcHJlZml4TWVzc2FnZSxcbiAgICAgICAgICAgIGRpZmZPYmpUeXBlOiAnaG9vaycsXG4gICAgICAgICAgICBkaWZmZXJlbmNlczogZGlmZmVyZW5jZXMsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgcHJldjogcHJldk93bmVyRGF0YS5ob29rc1tpXS5yZXN1bHQsXG4gICAgICAgICAgICAgIG5leHQ6IG5leHRPd25lckRhdGEuaG9va3NbaV0ucmVzdWx0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaG9va05hbWU6IGhvb2tOYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgd2R5clN0b3JlLm9wdGlvbnMuY29uc29sZUdyb3VwRW5kKCk7XG4gICAgfVxuICAgIGlmICghcmVhc29uLnByb3BzRGlmZmVyZW5jZXMgJiYgIXJlYXNvbi5zdGF0ZURpZmZlcmVuY2VzICYmICFyZWFzb24uaG9va0RpZmZlcmVuY2VzKSB7XG4gICAgICB3ZHlyU3RvcmUub3B0aW9ucy5jb25zb2xlTG9nKF9kZWZpbmVQcm9wZXJ0eSh7fSwgZGlzcGxheU5hbWUsIENvbXBvbmVudCksICdSZS1yZW5kZXJlZCBhbHRob3VnaCBwcm9wcyBhbmQgc3RhdGUgb2JqZWN0cyBhcmUgdGhlIHNhbWUuJywgJ1RoaXMgdXN1YWxseSBtZWFucyB0aGVyZSB3YXMgYSBjYWxsIHRvIHRoaXMuZm9yY2VVcGRhdGUoKSBpbnNpZGUgdGhlIGNvbXBvbmVudC4nLCBcIm1vcmUgaW5mbyBhdCBcIi5jb25jYXQobW9yZUluZm9VcmwpKTtcbiAgICB9XG4gICAgd2R5clN0b3JlLm9wdGlvbnMuY29uc29sZUdyb3VwRW5kKCk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlRGVmYXVsdE5vdGlmaWVyKGhvdFJlbG9hZEJ1ZmZlck1zKSB7XG4gICAgaWYgKGhvdFJlbG9hZEJ1ZmZlck1zKSB7XG4gICAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmhvdCAmJiBtb2R1bGUuaG90LmFkZFN0YXR1c0hhbmRsZXIpIHtcbiAgICAgICAgbW9kdWxlLmhvdC5hZGRTdGF0dXNIYW5kbGVyKGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICAgICAgICBpZiAoc3RhdHVzID09PSAnaWRsZScpIHtcbiAgICAgICAgICAgIGluSG90UmVsb2FkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpbkhvdFJlbG9hZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSwgaG90UmVsb2FkQnVmZmVyTXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0Tm90aWZpZXI7XG4gIH1cblxuICB2YXIgZW1wdHlGbiA9IGZ1bmN0aW9uIGVtcHR5Rm4oKSB7fTtcbiAgZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9ucygpIHtcbiAgICB2YXIgdXNlck9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBjb25zb2xlR3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgIHZhciBjb25zb2xlR3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgIGlmICh1c2VyT3B0aW9ucy5jb2xsYXBzZUdyb3Vwcykge1xuICAgICAgY29uc29sZUdyb3VwID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICB9IGVsc2UgaWYgKHVzZXJPcHRpb25zLm9ubHlMb2dzKSB7XG4gICAgICBjb25zb2xlR3JvdXAgPSBjb25zb2xlLmxvZztcbiAgICAgIGNvbnNvbGVHcm91cEVuZCA9IGVtcHR5Rm47XG4gICAgfVxuICAgIHZhciBub3RpZmllciA9IHVzZXJPcHRpb25zLm5vdGlmaWVyIHx8IGNyZWF0ZURlZmF1bHROb3RpZmllcignaG90UmVsb2FkQnVmZmVyTXMnIGluIHVzZXJPcHRpb25zID8gdXNlck9wdGlvbnMuaG90UmVsb2FkQnVmZmVyTXMgOiA1MDApO1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMih7XG4gICAgICBpbmNsdWRlOiBudWxsLFxuICAgICAgZXhjbHVkZTogbnVsbCxcbiAgICAgIG5vdGlmaWVyOiBub3RpZmllcixcbiAgICAgIG9ubHlMb2dzOiBmYWxzZSxcbiAgICAgIGNvbnNvbGVMb2c6IGNvbnNvbGUubG9nLFxuICAgICAgY29uc29sZUdyb3VwOiBjb25zb2xlR3JvdXAsXG4gICAgICBjb25zb2xlR3JvdXBFbmQ6IGNvbnNvbGVHcm91cEVuZCxcbiAgICAgIGxvZ09uRGlmZmVyZW50VmFsdWVzOiBmYWxzZSxcbiAgICAgIGxvZ093bmVyUmVhc29uczogdHJ1ZSxcbiAgICAgIHRyYWNrSG9va3M6IHRydWUsXG4gICAgICB0aXRsZUNvbG9yOiAnIzA1OCcsXG4gICAgICBkaWZmTmFtZUNvbG9yOiAnYmx1ZScsXG4gICAgICBkaWZmUGF0aENvbG9yOiAncmVkJyxcbiAgICAgIHRyYWNrRXh0cmFIb29rczogW10sXG4gICAgICB0cmFja0FsbFB1cmVDb21wb25lbnRzOiBmYWxzZVxuICAgIH0sIHVzZXJPcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgdHlwZS50eXBlICYmIGdldERpc3BsYXlOYW1lKHR5cGUudHlwZSkgfHwgdHlwZS5yZW5kZXIgJiYgZ2V0RGlzcGxheU5hbWUodHlwZS5yZW5kZXIpIHx8IChsb2Rhc2guaXNTdHJpbmcodHlwZSkgPyB0eXBlIDogJ1Vua25vd24nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcyh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUuZGVmYXVsdFByb3BzIHx8IHR5cGUudHlwZSAmJiBnZXREZWZhdWx0UHJvcHModHlwZS50eXBlKSB8fCB0eXBlLnJlbmRlciAmJiBnZXREZWZhdWx0UHJvcHModHlwZS5yZW5kZXIpIHx8IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBlbXB0eU9iamVjdCA9IHt9O1xuICBmdW5jdGlvbiBmaW5kT2JqZWN0c0RpZmZlcmVuY2VzKHVzZXJQcmV2T2JqLCB1c2VyTmV4dE9iaikge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgIF9yZWYkc2hhbGxvdyA9IF9yZWYuc2hhbGxvdyxcbiAgICAgIHNoYWxsb3cgPSBfcmVmJHNoYWxsb3cgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJHNoYWxsb3c7XG4gICAgaWYgKHVzZXJQcmV2T2JqID09PSB1c2VyTmV4dE9iaikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXNoYWxsb3cpIHtcbiAgICAgIHJldHVybiBjYWxjdWxhdGVEZWVwRXF1YWxEaWZmcyh1c2VyUHJldk9iaiwgdXNlck5leHRPYmopO1xuICAgIH1cbiAgICB2YXIgcHJldk9iaiA9IHVzZXJQcmV2T2JqIHx8IGVtcHR5T2JqZWN0O1xuICAgIHZhciBuZXh0T2JqID0gdXNlck5leHRPYmogfHwgZW1wdHlPYmplY3Q7XG4gICAgdmFyIGtleXNPZkJvdGhPYmplY3RzID0gT2JqZWN0LmtleXMoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHByZXZPYmopLCBuZXh0T2JqKSk7XG4gICAgcmV0dXJuIGxvZGFzaC5yZWR1Y2Uoa2V5c09mQm90aE9iamVjdHMsIGZ1bmN0aW9uIChyZXN1bHQsIGtleSkge1xuICAgICAgdmFyIGRlZXBFcXVhbERpZmZzID0gY2FsY3VsYXRlRGVlcEVxdWFsRGlmZnMocHJldk9ialtrZXldLCBuZXh0T2JqW2tleV0sIGtleSk7XG4gICAgICBpZiAoZGVlcEVxdWFsRGlmZnMpIHtcbiAgICAgICAgcmVzdWx0ID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZXN1bHQpLCBfdG9Db25zdW1hYmxlQXJyYXkoZGVlcEVxdWFsRGlmZnMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T3duZXJEaWZmZXJlbmNlcyhfcmVmKSB7XG4gICAgdmFyIHByZXZPd25lckRhdGEgPSBfcmVmLnByZXZPd25lckRhdGEsXG4gICAgICBuZXh0T3duZXJEYXRhID0gX3JlZi5uZXh0T3duZXJEYXRhO1xuICAgIGlmICghcHJldk93bmVyRGF0YSB8fCAhbmV4dE93bmVyRGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGluIHN0cmljdCBtb2RlIHByZXZPd25lckRhdGEgbWlnaHQgYmUgdHdpY2UgYXMgbGVuZ3RoeSBiZWNhdXNlIG9mIGRvdWJsZSByZW5kZXJzXG4gICAgdmFyIHByZXZPd25lckRhdGFIb29rcyA9IHByZXZPd25lckRhdGEuaG9va3MubGVuZ3RoID09PSBuZXh0T3duZXJEYXRhLmhvb2tzLmxlbmd0aCAqIDIgPyBwcmV2T3duZXJEYXRhLmhvb2tzLnNsaWNlKHByZXZPd25lckRhdGEuaG9va3MubGVuZ3RoIC8gMikgOiBwcmV2T3duZXJEYXRhLmhvb2tzO1xuICAgIHZhciBob29rRGlmZmVyZW5jZXMgPSBwcmV2T3duZXJEYXRhSG9va3MubWFwKGZ1bmN0aW9uIChfcmVmMiwgaSkge1xuICAgICAgdmFyIGhvb2tOYW1lID0gX3JlZjIuaG9va05hbWUsXG4gICAgICAgIHJlc3VsdCA9IF9yZWYyLnJlc3VsdDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhvb2tOYW1lOiBob29rTmFtZSxcbiAgICAgICAgZGlmZmVyZW5jZXM6IGZpbmRPYmplY3RzRGlmZmVyZW5jZXMocmVzdWx0LCBuZXh0T3duZXJEYXRhLmhvb2tzW2ldLnJlc3VsdCwge1xuICAgICAgICAgIHNoYWxsb3c6IGZhbHNlXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBwcm9wc0RpZmZlcmVuY2VzOiBmaW5kT2JqZWN0c0RpZmZlcmVuY2VzKHByZXZPd25lckRhdGEucHJvcHMsIG5leHRPd25lckRhdGEucHJvcHMpLFxuICAgICAgc3RhdGVEaWZmZXJlbmNlczogZmluZE9iamVjdHNEaWZmZXJlbmNlcyhwcmV2T3duZXJEYXRhLnN0YXRlLCBuZXh0T3duZXJEYXRhLnN0YXRlKSxcbiAgICAgIGhvb2tEaWZmZXJlbmNlczogaG9va0RpZmZlcmVuY2VzLmxlbmd0aCA+IDAgPyBob29rRGlmZmVyZW5jZXMgOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VXBkYXRlUmVhc29uKHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2SG9vaywgbmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRIb29rKSB7XG4gICAgdmFyIHByZXZPd25lckRhdGEgPSB3ZHlyU3RvcmUub3duZXJEYXRhTWFwLmdldChwcmV2UHJvcHMpO1xuICAgIHZhciBuZXh0T3duZXJEYXRhID0gd2R5clN0b3JlLm93bmVyRGF0YU1hcC5nZXQobmV4dFByb3BzKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvcHNEaWZmZXJlbmNlczogZmluZE9iamVjdHNEaWZmZXJlbmNlcyhwcmV2UHJvcHMsIG5leHRQcm9wcyksXG4gICAgICBzdGF0ZURpZmZlcmVuY2VzOiBmaW5kT2JqZWN0c0RpZmZlcmVuY2VzKHByZXZTdGF0ZSwgbmV4dFN0YXRlKSxcbiAgICAgIGhvb2tEaWZmZXJlbmNlczogZmluZE9iamVjdHNEaWZmZXJlbmNlcyhwcmV2SG9vaywgbmV4dEhvb2ssIHtcbiAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICAgIH0pLFxuICAgICAgb3duZXJEaWZmZXJlbmNlczogZ2V0T3duZXJEaWZmZXJlbmNlcyh7XG4gICAgICAgIHByZXZPd25lckRhdGE6IHByZXZPd25lckRhdGEsXG4gICAgICAgIG5leHRPd25lckRhdGE6IG5leHRPd25lckRhdGFcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBnZXRVcGRhdGVJbmZvKF9yZWYzKSB7XG4gICAgdmFyIENvbXBvbmVudCA9IF9yZWYzLkNvbXBvbmVudCxcbiAgICAgIGRpc3BsYXlOYW1lID0gX3JlZjMuZGlzcGxheU5hbWUsXG4gICAgICBob29rTmFtZSA9IF9yZWYzLmhvb2tOYW1lLFxuICAgICAgcHJldlByb3BzID0gX3JlZjMucHJldlByb3BzLFxuICAgICAgcHJldlN0YXRlID0gX3JlZjMucHJldlN0YXRlLFxuICAgICAgcHJldkhvb2sgPSBfcmVmMy5wcmV2SG9vayxcbiAgICAgIG5leHRQcm9wcyA9IF9yZWYzLm5leHRQcm9wcyxcbiAgICAgIG5leHRTdGF0ZSA9IF9yZWYzLm5leHRTdGF0ZSxcbiAgICAgIG5leHRIb29rID0gX3JlZjMubmV4dEhvb2s7XG4gICAgcmV0dXJuIHtcbiAgICAgIENvbXBvbmVudDogQ29tcG9uZW50LFxuICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgaG9va05hbWU6IGhvb2tOYW1lLFxuICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICBwcmV2U3RhdGU6IHByZXZTdGF0ZSxcbiAgICAgIHByZXZIb29rOiBwcmV2SG9vayxcbiAgICAgIG5leHRQcm9wczogbmV4dFByb3BzLFxuICAgICAgbmV4dFN0YXRlOiBuZXh0U3RhdGUsXG4gICAgICBuZXh0SG9vazogbmV4dEhvb2ssXG4gICAgICByZWFzb246IGdldFVwZGF0ZVJlYXNvbihwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkhvb2ssIG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0SG9vaylcbiAgICB9O1xuICB9XG5cbiAgLy8gY29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0VHlwZU9mTW9kZS5qc1xuXG4gIC8vIGJhc2VkIG9uIFwiZmluZFN0cmljdFJvb3RcIiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21hc3Rlci9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5qc1xuICAvLyBub3RpY2U6IHRoaXMgaXMgb25seSB1c2VkIGZvciBjbGFzcyBjb21wb25lbnRzLiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgZG9lc24ndCByZW5kZXIgdHdpY2UgaW5zaWRlIHN0cmljdCBtb2RlXG4gIGZ1bmN0aW9uIGNoZWNrSWZJbnNpZGVBU3RyaWN0TW9kZVRyZWUocmVhY3RDb21wb25lbnRJbnN0YW5jZSkge1xuICAgIHZhciByZWFjdEludGVybmFsRmliZXIgPSByZWFjdENvbXBvbmVudEluc3RhbmNlICYmIChyZWFjdENvbXBvbmVudEluc3RhbmNlLl9yZWFjdEludGVybmFsRmliZXIgfHwgcmVhY3RDb21wb25lbnRJbnN0YW5jZS5fcmVhY3RJbnRlcm5hbHMpO1xuICAgIHdoaWxlIChyZWFjdEludGVybmFsRmliZXIpIHtcbiAgICAgIGlmIChyZWFjdEludGVybmFsRmliZXIubW9kZSAmIFJFQUNUX1NUUklDVF9NT0RFKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmVhY3RJbnRlcm5hbEZpYmVyID0gcmVhY3RJbnRlcm5hbEZpYmVyW1wicmV0dXJuXCJdO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gaXNSZWFjdENsYXNzQ29tcG9uZW50KENvbXBvbmVudCkge1xuICAgIHJldHVybiBDb21wb25lbnQucHJvdG90eXBlICYmICEhQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50O1xuICB9XG4gIGZ1bmN0aW9uIGlzTWVtb0NvbXBvbmVudChDb21wb25lbnQpIHtcbiAgICByZXR1cm4gQ29tcG9uZW50LiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEU7XG4gIH1cbiAgZnVuY3Rpb24gaXNGb3J3YXJkUmVmQ29tcG9uZW50KENvbXBvbmVudCkge1xuICAgIHJldHVybiBDb21wb25lbnQuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbmNsdWRlKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIHdkeXJTdG9yZS5vcHRpb25zLmluY2x1ZGUgJiYgd2R5clN0b3JlLm9wdGlvbnMuaW5jbHVkZS5sZW5ndGggPiAwICYmIHdkeXJTdG9yZS5vcHRpb25zLmluY2x1ZGUuc29tZShmdW5jdGlvbiAocmVnZXgpIHtcbiAgICAgIHJldHVybiByZWdleC50ZXN0KGRpc3BsYXlOYW1lKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzaG91bGRFeGNsdWRlKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIHdkeXJTdG9yZS5vcHRpb25zLmV4Y2x1ZGUgJiYgd2R5clN0b3JlLm9wdGlvbnMuZXhjbHVkZS5sZW5ndGggPiAwICYmIHdkeXJTdG9yZS5vcHRpb25zLmV4Y2x1ZGUuc29tZShmdW5jdGlvbiAocmVnZXgpIHtcbiAgICAgIHJldHVybiByZWdleC50ZXN0KGRpc3BsYXlOYW1lKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzaG91bGRUcmFjayhDb21wb25lbnQsIF9yZWYpIHtcbiAgICB2YXIgaXNIb29rQ2hhbmdlID0gX3JlZi5pc0hvb2tDaGFuZ2U7XG4gICAgdmFyIGRpc3BsYXlOYW1lID0gZ2V0RGlzcGxheU5hbWUoQ29tcG9uZW50KTtcbiAgICBpZiAoc2hvdWxkRXhjbHVkZShkaXNwbGF5TmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKENvbXBvbmVudC53aHlEaWRZb3VSZW5kZXIgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc0hvb2tDaGFuZ2UgJiYgQ29tcG9uZW50LndoeURpZFlvdVJlbmRlciAmJiBDb21wb25lbnQud2h5RGlkWW91UmVuZGVyLnRyYWNrSG9va3MgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAhIShDb21wb25lbnQud2h5RGlkWW91UmVuZGVyIHx8IHdkeXJTdG9yZS5vcHRpb25zLnRyYWNrQWxsUHVyZUNvbXBvbmVudHMgJiYgKENvbXBvbmVudCAmJiBDb21wb25lbnQucHJvdG90eXBlIGluc3RhbmNlb2Ygd2R5clN0b3JlLlJlYWN0LlB1cmVDb21wb25lbnQgfHwgaXNNZW1vQ29tcG9uZW50KENvbXBvbmVudCkpIHx8IHNob3VsZEluY2x1ZGUoZGlzcGxheU5hbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoQ2xhc3NDb21wb25lbnQoQ2xhc3NDb21wb25lbnQsIF9yZWYpIHtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBfcmVmLmRpc3BsYXlOYW1lLFxuICAgICAgZGVmYXVsdFByb3BzID0gX3JlZi5kZWZhdWx0UHJvcHM7XG4gICAgdmFyIFdEWVJQYXRjaGVkQ2xhc3NDb21wb25lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DbGFzc0NvbXBvbmVudCkge1xuICAgICAgZnVuY3Rpb24gV0RZUlBhdGNoZWRDbGFzc0NvbXBvbmVudChwcm9wcywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXRFlSUGF0Y2hlZENsYXNzQ29tcG9uZW50KTtcbiAgICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIFdEWVJQYXRjaGVkQ2xhc3NDb21wb25lbnQsIFtwcm9wcywgY29udGV4dF0pO1xuICAgICAgICBfdGhpcy5fV0RZUiA9IHtcbiAgICAgICAgICByZW5kZXJOdW1iZXI6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9yaWdSZW5kZXIgPSBfZ2V0KChfZ2V0UHJvdG90eXBlT2YoV0RZUlBhdGNoZWRDbGFzc0NvbXBvbmVudC5wcm90b3R5cGUpKSwgXCJyZW5kZXJcIiwgX3RoaXMpIHx8IF90aGlzLnJlbmRlcjtcblxuICAgICAgICAvLyB0aGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgcmVuZGVyIGlzIGFuIGFycm93IGZ1bmN0aW9uIG9yIHRoaXMucmVuZGVyLmJpbmQodGhpcykgd2FzIGNhbGxlZCBvbiB0aGUgb3JpZ2luYWwgY2xhc3NcbiAgICAgICAgdmFyIHJlbmRlcklzQUJpbmRlZEZ1bmN0aW9uID0gb3JpZ1JlbmRlciAhPT0gQ2xhc3NDb21wb25lbnQucHJvdG90eXBlLnJlbmRlcjtcbiAgICAgICAgaWYgKHJlbmRlcklzQUJpbmRlZEZ1bmN0aW9uKSB7XG4gICAgICAgICAgX3RoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgV0RZUlBhdGNoZWRDbGFzc0NvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyLmFwcGx5KF90aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBvcmlnUmVuZGVyKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9XG4gICAgICBfaW5oZXJpdHMoV0RZUlBhdGNoZWRDbGFzc0NvbXBvbmVudCwgX0NsYXNzQ29tcG9uZW50KTtcbiAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoV0RZUlBhdGNoZWRDbGFzc0NvbXBvbmVudCwgW3tcbiAgICAgICAga2V5OiBcInJlbmRlclwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICAgIHRoaXMuX1dEWVIucmVuZGVyTnVtYmVyKys7XG4gICAgICAgICAgaWYgKCEoJ2lzU3RyaWN0TW9kZScgaW4gdGhpcy5fV0RZUikpIHtcbiAgICAgICAgICAgIHRoaXMuX1dEWVIuaXNTdHJpY3RNb2RlID0gY2hlY2tJZkluc2lkZUFTdHJpY3RNb2RlVHJlZSh0aGlzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpbiBzdHJpY3QgbW9kZS0gaWdub3JlIGV2ZXJ5IG90aGVyIHJlbmRlclxuICAgICAgICAgIGlmICghKHRoaXMuX1dEWVIuaXNTdHJpY3RNb2RlICYmIHRoaXMuX1dEWVIucmVuZGVyTnVtYmVyICUgMiA9PT0gMSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9XRFlSLnByZXZQcm9wcykge1xuICAgICAgICAgICAgICB2YXIgdXBkYXRlSW5mbyA9IGdldFVwZGF0ZUluZm8oe1xuICAgICAgICAgICAgICAgIENvbXBvbmVudDogQ2xhc3NDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgICAgIHByZXZQcm9wczogdGhpcy5fV0RZUi5wcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgcHJldlN0YXRlOiB0aGlzLl9XRFlSLnByZXZTdGF0ZSxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlOiB0aGlzLnN0YXRlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB3ZHlyU3RvcmUub3B0aW9ucy5ub3RpZmllcih1cGRhdGVJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX1dEWVIucHJldlByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIHRoaXMuX1dEWVIucHJldlN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKFdEWVJQYXRjaGVkQ2xhc3NDb21wb25lbnQucHJvdG90eXBlKSwgXCJyZW5kZXJcIiwgdGhpcykgPyBfZ2V0KF9nZXRQcm90b3R5cGVPZihXRFlSUGF0Y2hlZENsYXNzQ29tcG9uZW50LnByb3RvdHlwZSksIFwicmVuZGVyXCIsIHRoaXMpLmNhbGwodGhpcykgOiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XSk7XG4gICAgfShDbGFzc0NvbXBvbmVudCk7XG4gICAgdHJ5IHtcbiAgICAgIFdEWVJQYXRjaGVkQ2xhc3NDb21wb25lbnQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBub3QgY3J1Y2lhbCBpZiBkaXNwbGF5TmFtZSBjb3VsZG4ndCBiZSBzZXRcbiAgICB9XG4gICAgV0RZUlBhdGNoZWRDbGFzc0NvbXBvbmVudC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4gICAgbG9kYXNoLmRlZmF1bHRzKFdEWVJQYXRjaGVkQ2xhc3NDb21wb25lbnQsIENsYXNzQ29tcG9uZW50KTtcbiAgICByZXR1cm4gV0RZUlBhdGNoZWRDbGFzc0NvbXBvbmVudDtcbiAgfVxuXG4gIHZhciBnZXRGdW5jdGlvbmFsQ29tcG9uZW50RnJvbVN0cmluZ0NvbXBvbmVudCA9IGZ1bmN0aW9uIGdldEZ1bmN0aW9uYWxDb21wb25lbnRGcm9tU3RyaW5nQ29tcG9uZW50KGNvbXBvbmVudFR5cGVTdHIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICByZXR1cm4gd2R5clN0b3JlLlJlYWN0LmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50VHlwZVN0ciwgcHJvcHMpO1xuICAgIH07XG4gIH07XG4gIGZ1bmN0aW9uIHBhdGNoRnVuY3Rpb25hbE9yU3RyQ29tcG9uZW50KEZ1bmN0aW9uYWxPclN0cmluZ0NvbXBvbmVudCwgX3JlZikge1xuICAgIHZhciBpc1B1cmUgPSBfcmVmLmlzUHVyZSxcbiAgICAgIGRpc3BsYXlOYW1lID0gX3JlZi5kaXNwbGF5TmFtZSxcbiAgICAgIGRlZmF1bHRQcm9wcyA9IF9yZWYuZGVmYXVsdFByb3BzO1xuICAgIHZhciBGdW5jdGlvbmFsQ29tcG9uZW50ID0gdHlwZW9mIEZ1bmN0aW9uYWxPclN0cmluZ0NvbXBvbmVudCA9PT0gJ3N0cmluZycgPyBnZXRGdW5jdGlvbmFsQ29tcG9uZW50RnJvbVN0cmluZ0NvbXBvbmVudChGdW5jdGlvbmFsT3JTdHJpbmdDb21wb25lbnQpIDogRnVuY3Rpb25hbE9yU3RyaW5nQ29tcG9uZW50O1xuICAgIGZ1bmN0aW9uIFdEWVJGdW5jdGlvbmFsQ29tcG9uZW50KCkge1xuICAgICAgdmFyIG5leHRQcm9wcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciByZWYgPSB3ZHlyU3RvcmUuUmVhY3QudXNlUmVmKCk7XG4gICAgICB2YXIgcHJldlByb3BzID0gcmVmLmN1cnJlbnQ7XG4gICAgICByZWYuY3VycmVudCA9IG5leHRQcm9wcztcbiAgICAgIGlmIChwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIHVwZGF0ZUluZm8gPSBnZXRVcGRhdGVJbmZvKHtcbiAgICAgICAgICBDb21wb25lbnQ6IEZ1bmN0aW9uYWxDb21wb25lbnQsXG4gICAgICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICAgIHByZXZQcm9wczogcHJldlByb3BzLFxuICAgICAgICAgIG5leHRQcm9wczogbmV4dFByb3BzXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbm90aWZpZWRCeUhvb2tzID0gIXVwZGF0ZUluZm8ucmVhc29uLnByb3BzRGlmZmVyZW5jZXMgfHwgaXNQdXJlICYmIHVwZGF0ZUluZm8ucmVhc29uLnByb3BzRGlmZmVyZW5jZXMubGVuZ3RoID09PSAwO1xuICAgICAgICBpZiAoIW5vdGlmaWVkQnlIb29rcykge1xuICAgICAgICAgIHdkeXJTdG9yZS5vcHRpb25zLm5vdGlmaWVyKHVwZGF0ZUluZm8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gRnVuY3Rpb25hbENvbXBvbmVudC5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBXRFlSRnVuY3Rpb25hbENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIG5vdCBjcnVjaWFsIGlmIGRpc3BsYXlOYW1lIGNvdWxkbid0IGJlIHNldFxuICAgIH1cbiAgICBXRFlSRnVuY3Rpb25hbENvbXBvbmVudC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4gICAgV0RZUkZ1bmN0aW9uYWxDb21wb25lbnQuQ29tcG9uZW50Rm9ySG9va3NUcmFja2luZyA9IEZ1bmN0aW9uYWxDb21wb25lbnQ7XG4gICAgbG9kYXNoLmRlZmF1bHRzKFdEWVJGdW5jdGlvbmFsQ29tcG9uZW50LCBGdW5jdGlvbmFsQ29tcG9uZW50KTtcbiAgICByZXR1cm4gV0RZUkZ1bmN0aW9uYWxDb21wb25lbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaE1lbW9Db21wb25lbnQoTWVtb0NvbXBvbmVudCwgX3JlZikge1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IF9yZWYuZGlzcGxheU5hbWUsXG4gICAgICBkZWZhdWx0UHJvcHMgPSBfcmVmLmRlZmF1bHRQcm9wcztcbiAgICB2YXIgSW5uZXJNZW1vQ29tcG9uZW50ID0gTWVtb0NvbXBvbmVudC50eXBlO1xuICAgIHZhciBpc0lubmVyTWVtb0NvbXBvbmVudEFDbGFzc0NvbXBvbmVudCA9IGlzUmVhY3RDbGFzc0NvbXBvbmVudChJbm5lck1lbW9Db21wb25lbnQpO1xuICAgIHZhciBpc0lubmVyTWVtb0NvbXBvbmVudEZvcndhcmRSZWZzID0gaXNGb3J3YXJkUmVmQ29tcG9uZW50KElubmVyTWVtb0NvbXBvbmVudCk7XG4gICAgdmFyIGlzSW5uZXJNZW1vQ29tcG9uZW50QW5vdGhlck1lbW9Db21wb25lbnQgPSBpc01lbW9Db21wb25lbnQoSW5uZXJNZW1vQ29tcG9uZW50KTtcbiAgICB2YXIgV3JhcHBlZEZ1bmN0aW9uYWxDb21wb25lbnQgPSBpc0lubmVyTWVtb0NvbXBvbmVudEZvcndhcmRSZWZzID8gSW5uZXJNZW1vQ29tcG9uZW50LnJlbmRlciA6IElubmVyTWVtb0NvbXBvbmVudDtcbiAgICB2YXIgUGF0Y2hlZElubmVyQ29tcG9uZW50ID0gaXNJbm5lck1lbW9Db21wb25lbnRBQ2xhc3NDb21wb25lbnQgPyBwYXRjaENsYXNzQ29tcG9uZW50KFdyYXBwZWRGdW5jdGlvbmFsQ29tcG9uZW50LCB7XG4gICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICBkZWZhdWx0UHJvcHM6IGRlZmF1bHRQcm9wc1xuICAgIH0pIDogaXNJbm5lck1lbW9Db21wb25lbnRBbm90aGVyTWVtb0NvbXBvbmVudCA/IHBhdGNoTWVtb0NvbXBvbmVudChXcmFwcGVkRnVuY3Rpb25hbENvbXBvbmVudCwge1xuICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgZGVmYXVsdFByb3BzOiBkZWZhdWx0UHJvcHNcbiAgICB9KSA6IHBhdGNoRnVuY3Rpb25hbE9yU3RyQ29tcG9uZW50KFdyYXBwZWRGdW5jdGlvbmFsQ29tcG9uZW50LCB7XG4gICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICBpc1B1cmU6IHRydWVcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgUGF0Y2hlZElubmVyQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gZ2V0RGlzcGxheU5hbWUoV3JhcHBlZEZ1bmN0aW9uYWxDb21wb25lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIG5vdCBjcnVjaWFsIGlmIGRpc3BsYXlOYW1lIGNvdWxkbid0IGJlIHNldFxuICAgIH1cbiAgICBQYXRjaGVkSW5uZXJDb21wb25lbnQuQ29tcG9uZW50Rm9ySG9va3NUcmFja2luZyA9IE1lbW9Db21wb25lbnQ7XG4gICAgbG9kYXNoLmRlZmF1bHRzKFBhdGNoZWRJbm5lckNvbXBvbmVudCwgV3JhcHBlZEZ1bmN0aW9uYWxDb21wb25lbnQpO1xuICAgIHZhciBXRFlSTWVtb2l6ZWRGdW5jdGlvbmFsQ29tcG9uZW50ID0gd2R5clN0b3JlLlJlYWN0Lm1lbW8oaXNJbm5lck1lbW9Db21wb25lbnRGb3J3YXJkUmVmcyA/IHdkeXJTdG9yZS5SZWFjdC5mb3J3YXJkUmVmKFBhdGNoZWRJbm5lckNvbXBvbmVudCkgOiBQYXRjaGVkSW5uZXJDb21wb25lbnQsIE1lbW9Db21wb25lbnQuY29tcGFyZSk7XG4gICAgdHJ5IHtcbiAgICAgIFdEWVJNZW1vaXplZEZ1bmN0aW9uYWxDb21wb25lbnQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBub3QgY3J1Y2lhbCBpZiBkaXNwbGF5TmFtZSBjb3VsZG4ndCBiZSBzZXRcbiAgICB9XG4gICAgV0RZUk1lbW9pemVkRnVuY3Rpb25hbENvbXBvbmVudC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4gICAgbG9kYXNoLmRlZmF1bHRzKFdEWVJNZW1vaXplZEZ1bmN0aW9uYWxDb21wb25lbnQsIE1lbW9Db21wb25lbnQpO1xuICAgIHJldHVybiBXRFlSTWVtb2l6ZWRGdW5jdGlvbmFsQ29tcG9uZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hGb3J3YXJkUmVmQ29tcG9uZW50KEZvcndhcmRSZWZDb21wb25lbnQsIF9yZWYpIHtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBfcmVmLmRpc3BsYXlOYW1lLFxuICAgICAgZGVmYXVsdFByb3BzID0gX3JlZi5kZWZhdWx0UHJvcHM7XG4gICAgdmFyIElubmVyRm9yd2FyZFJlZkNvbXBvbmVudCA9IEZvcndhcmRSZWZDb21wb25lbnQucmVuZGVyO1xuICAgIHZhciBpc0lubmVyQ29tcG9uZW50TWVtb2l6ZWQgPSBpc01lbW9Db21wb25lbnQoSW5uZXJGb3J3YXJkUmVmQ29tcG9uZW50KTtcbiAgICB2YXIgV3JhcHBlZEZ1bmN0aW9uYWxDb21wb25lbnQgPSBpc0lubmVyQ29tcG9uZW50TWVtb2l6ZWQgPyBJbm5lckZvcndhcmRSZWZDb21wb25lbnQudHlwZSA6IElubmVyRm9yd2FyZFJlZkNvbXBvbmVudDtcbiAgICB2YXIgV0RZUldyYXBwZWRCeVJlYWN0Rm9yd2FyZFJlZkZ1bmN0aW9uYWxDb21wb25lbnQgPSBwYXRjaEZ1bmN0aW9uYWxPclN0ckNvbXBvbmVudChXcmFwcGVkRnVuY3Rpb25hbENvbXBvbmVudCwge1xuICAgICAgaXNQdXJlOiBpc0lubmVyQ29tcG9uZW50TWVtb2l6ZWQsXG4gICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWVcbiAgICB9KTtcbiAgICBXRFlSV3JhcHBlZEJ5UmVhY3RGb3J3YXJkUmVmRnVuY3Rpb25hbENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lKFdyYXBwZWRGdW5jdGlvbmFsQ29tcG9uZW50KTtcbiAgICBXRFlSV3JhcHBlZEJ5UmVhY3RGb3J3YXJkUmVmRnVuY3Rpb25hbENvbXBvbmVudC5Db21wb25lbnRGb3JIb29rc1RyYWNraW5nID0gV3JhcHBlZEZ1bmN0aW9uYWxDb21wb25lbnQ7XG4gICAgbG9kYXNoLmRlZmF1bHRzKFdEWVJXcmFwcGVkQnlSZWFjdEZvcndhcmRSZWZGdW5jdGlvbmFsQ29tcG9uZW50LCBXcmFwcGVkRnVuY3Rpb25hbENvbXBvbmVudCk7XG4gICAgdmFyIFdEWVJGb3J3YXJkUmVmRnVuY3Rpb25hbENvbXBvbmVudCA9IHdkeXJTdG9yZS5SZWFjdC5mb3J3YXJkUmVmKGlzSW5uZXJDb21wb25lbnRNZW1vaXplZCA/IHdkeXJTdG9yZS5SZWFjdC5tZW1vKFdEWVJXcmFwcGVkQnlSZWFjdEZvcndhcmRSZWZGdW5jdGlvbmFsQ29tcG9uZW50LCBJbm5lckZvcndhcmRSZWZDb21wb25lbnQuY29tcGFyZSkgOiBXRFlSV3JhcHBlZEJ5UmVhY3RGb3J3YXJkUmVmRnVuY3Rpb25hbENvbXBvbmVudCk7XG4gICAgdHJ5IHtcbiAgICAgIFdEWVJGb3J3YXJkUmVmRnVuY3Rpb25hbENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIG5vdCBjcnVjaWFsIGlmIGRpc3BsYXlOYW1lIGNvdWxkbid0IGJlIHNldFxuICAgIH1cbiAgICBXRFlSRm9yd2FyZFJlZkZ1bmN0aW9uYWxDb21wb25lbnQuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuICAgIGxvZGFzaC5kZWZhdWx0cyhXRFlSRm9yd2FyZFJlZkZ1bmN0aW9uYWxDb21wb25lbnQsIEZvcndhcmRSZWZDb21wb25lbnQpO1xuICAgIHJldHVybiBXRFlSRm9yd2FyZFJlZkZ1bmN0aW9uYWxDb21wb25lbnQ7XG4gIH1cblxuICB2YXIgaW5pdGlhbEhvb2tWYWx1ZSA9IFN5bWJvbCgnaW5pdGlhbC1ob29rLXZhbHVlJyk7XG4gIGZ1bmN0aW9uIHRyYWNrSG9va0NoYW5nZXMoaG9va05hbWUsIF9yZWYsIGhvb2tSZXN1bHQpIHtcbiAgICB2YXIgaG9va1BhdGggPSBfcmVmLnBhdGg7XG4gICAgdmFyIG5leHRIb29rID0gaG9va1BhdGggPyBsb2Rhc2guZ2V0KGhvb2tSZXN1bHQsIGhvb2tQYXRoKSA6IGhvb2tSZXN1bHQ7XG4gICAgdmFyIHJlbmRlck51bWJlckZvclRoZUhvb2sgPSB3ZHlyU3RvcmUuUmVhY3QudXNlUmVmKHRydWUpO1xuXG4gICAgLy8gVE9ETzogaW1wcm92ZVxuICAgIHZhciBpc1NlY29uZEN5Y2xlT2ZSZW5kZXJzID0gd2R5clN0b3JlLmhvb2tzUGVyUmVuZGVyWzBdICYmIHdkeXJTdG9yZS5ob29rc1BlclJlbmRlclswXS5yZW5kZXJOdW1iZXJGb3JUaGVIb29rICE9PSByZW5kZXJOdW1iZXJGb3JUaGVIb29rLmN1cnJlbnQ7XG4gICAgaWYgKGlzU2Vjb25kQ3ljbGVPZlJlbmRlcnMpIHtcbiAgICAgIHdkeXJTdG9yZS5ob29rc1BlclJlbmRlciA9IFtdO1xuICAgIH1cbiAgICB3ZHlyU3RvcmUuaG9va3NQZXJSZW5kZXIucHVzaCh7XG4gICAgICBob29rTmFtZTogaG9va05hbWUsXG4gICAgICByZXN1bHQ6IG5leHRIb29rLFxuICAgICAgcmVuZGVyTnVtYmVyRm9yVGhlSG9vazogcmVuZGVyTnVtYmVyRm9yVGhlSG9vay5jdXJyZW50XG4gICAgfSk7XG4gICAgcmVuZGVyTnVtYmVyRm9yVGhlSG9vay5jdXJyZW50Kys7XG4gICAgdmFyIENvbXBvbmVudEhvb2tEaXNwYXRjaGVkRnJvbUluc3RhbmNlID0gd2R5clN0b3JlLlJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEICYmIHdkeXJTdG9yZS5SZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIHZhciBwcmV2SG9va1JlZiA9IHdkeXJTdG9yZS5SZWFjdC51c2VSZWYoaW5pdGlhbEhvb2tWYWx1ZSk7XG4gICAgaWYgKCFDb21wb25lbnRIb29rRGlzcGF0Y2hlZEZyb21JbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIGhvb2tSZXN1bHQ7XG4gICAgfVxuICAgIHZhciBDb21wb25lbnQgPSBDb21wb25lbnRIb29rRGlzcGF0Y2hlZEZyb21JbnN0YW5jZS50eXBlLkNvbXBvbmVudEZvckhvb2tzVHJhY2tpbmcgfHwgQ29tcG9uZW50SG9va0Rpc3BhdGNoZWRGcm9tSW5zdGFuY2UudHlwZTtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZShDb21wb25lbnQpO1xuICAgIHZhciBpc1Nob3VsZFRyYWNrID0gc2hvdWxkVHJhY2soQ29tcG9uZW50LCB7XG4gICAgICBpc0hvb2tDaGFuZ2U6IHRydWVcbiAgICB9KTtcbiAgICBpZiAoIWlzU2hvdWxkVHJhY2spIHtcbiAgICAgIHJldHVybiBob29rUmVzdWx0O1xuICAgIH1cbiAgICB2YXIgbmV3UHJldkhvb2tSZWYgPSBwcmV2SG9va1JlZi5jdXJyZW50O1xuICAgIHByZXZIb29rUmVmLmN1cnJlbnQgPSBob29rUmVzdWx0O1xuICAgIGlmIChuZXdQcmV2SG9va1JlZiAhPT0gaW5pdGlhbEhvb2tWYWx1ZSkge1xuICAgICAgdmFyIG5vdGlmaWNhdGlvbiA9IGdldFVwZGF0ZUluZm8oe1xuICAgICAgICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICBob29rTmFtZTogaG9va05hbWUsXG4gICAgICAgIHByZXZIb29rOiBob29rUGF0aCA/IGxvZGFzaC5nZXQobmV3UHJldkhvb2tSZWYsIGhvb2tQYXRoKSA6IG5ld1ByZXZIb29rUmVmLFxuICAgICAgICBuZXh0SG9vazogbmV4dEhvb2tcbiAgICAgIH0pO1xuICAgICAgaWYgKG5vdGlmaWNhdGlvbi5yZWFzb24uaG9va0RpZmZlcmVuY2VzKSB7XG4gICAgICAgIHdkeXJTdG9yZS5vcHRpb25zLm5vdGlmaWVyKG5vdGlmaWNhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBob29rUmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVBhdGNoZWRDb21wb25lbnQoQ29tcG9uZW50LCBfcmVmMikge1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IF9yZWYyLmRpc3BsYXlOYW1lLFxuICAgICAgZGVmYXVsdFByb3BzID0gX3JlZjIuZGVmYXVsdFByb3BzO1xuICAgIGlmIChpc01lbW9Db21wb25lbnQoQ29tcG9uZW50KSkge1xuICAgICAgcmV0dXJuIHBhdGNoTWVtb0NvbXBvbmVudChDb21wb25lbnQsIHtcbiAgICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICBkZWZhdWx0UHJvcHM6IGRlZmF1bHRQcm9wc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc0ZvcndhcmRSZWZDb21wb25lbnQoQ29tcG9uZW50KSkge1xuICAgICAgcmV0dXJuIHBhdGNoRm9yd2FyZFJlZkNvbXBvbmVudChDb21wb25lbnQsIHtcbiAgICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICBkZWZhdWx0UHJvcHM6IGRlZmF1bHRQcm9wc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc1JlYWN0Q2xhc3NDb21wb25lbnQoQ29tcG9uZW50KSkge1xuICAgICAgcmV0dXJuIHBhdGNoQ2xhc3NDb21wb25lbnQoQ29tcG9uZW50LCB7XG4gICAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgICAgZGVmYXVsdFByb3BzOiBkZWZhdWx0UHJvcHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGF0Y2hGdW5jdGlvbmFsT3JTdHJDb21wb25lbnQoQ29tcG9uZW50LCB7XG4gICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICBkZWZhdWx0UHJvcHM6IGRlZmF1bHRQcm9wcyxcbiAgICAgIGlzUHVyZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRQYXRjaGVkQ29tcG9uZW50KENvbXBvbmVudCwgX3JlZjMpIHtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBfcmVmMy5kaXNwbGF5TmFtZSxcbiAgICAgIGRlZmF1bHRQcm9wcyA9IF9yZWYzLmRlZmF1bHRQcm9wcztcbiAgICBpZiAod2R5clN0b3JlLmNvbXBvbmVudHNNYXAuaGFzKENvbXBvbmVudCkpIHtcbiAgICAgIHJldHVybiB3ZHlyU3RvcmUuY29tcG9uZW50c01hcC5nZXQoQ29tcG9uZW50KTtcbiAgICB9XG4gICAgdmFyIFdEWVJQYXRjaGVkQ29tcG9uZW50ID0gY3JlYXRlUGF0Y2hlZENvbXBvbmVudChDb21wb25lbnQsIHtcbiAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgIGRlZmF1bHRQcm9wczogZGVmYXVsdFByb3BzXG4gICAgfSk7XG4gICAgd2R5clN0b3JlLmNvbXBvbmVudHNNYXAuc2V0KENvbXBvbmVudCwgV0RZUlBhdGNoZWRDb21wb25lbnQpO1xuICAgIHJldHVybiBXRFlSUGF0Y2hlZENvbXBvbmVudDtcbiAgfVxuICBmdW5jdGlvbiBnZXRJc1N1cHBvcnRlZENvbXBvbmVudFR5cGUoQ29tcCkge1xuICAgIGlmICghQ29tcCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNNZW1vQ29tcG9uZW50KENvbXApKSB7XG4gICAgICByZXR1cm4gZ2V0SXNTdXBwb3J0ZWRDb21wb25lbnRUeXBlKENvbXAudHlwZSk7XG4gICAgfVxuICAgIGlmIChpc0ZvcndhcmRSZWZDb21wb25lbnQoQ29tcCkpIHtcbiAgICAgIHJldHVybiBnZXRJc1N1cHBvcnRlZENvbXBvbmVudFR5cGUoQ29tcC5yZW5kZXIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIENvbXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICB2YXIgaG9va3NDb25maWcgPSB7XG4gICAgdXNlU3RhdGU6IHtcbiAgICAgIHBhdGg6ICcwJ1xuICAgIH0sXG4gICAgdXNlUmVkdWNlcjoge1xuICAgICAgcGF0aDogJzAnXG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiB1bmRlZmluZWQsXG4gICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IHVuZGVmaW5lZCxcbiAgICB1c2VNZW1vOiB7XG4gICAgICBkZXBlbmRlbmNpZXNQYXRoOiAnMScsXG4gICAgICBkb250UmVwb3J0OiB0cnVlXG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazoge1xuICAgICAgZGVwZW5kZW5jaWVzUGF0aDogJzEnLFxuICAgICAgZG9udFJlcG9ydDogdHJ1ZVxuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gc3RvcmVPd25lckRhdGEoZWxlbWVudCkge1xuICAgIHZhciBPd25lckluc3RhbmNlID0gd2R5clN0b3JlLlJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgaWYgKE93bmVySW5zdGFuY2UpIHtcbiAgICAgIHZhciBDb21wb25lbnQgPSBPd25lckluc3RhbmNlLnR5cGUuQ29tcG9uZW50Rm9ySG9va3NUcmFja2luZyB8fCBPd25lckluc3RhbmNlLnR5cGU7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZShDb21wb25lbnQpO1xuICAgICAgdmFyIGFkZGl0aW9uYWxPd25lckRhdGEgPSB7fTtcbiAgICAgIGlmICh3ZHlyU3RvcmUub3B0aW9ucy5nZXRBZGRpdGlvbmFsT3duZXJEYXRhKSB7XG4gICAgICAgIGFkZGl0aW9uYWxPd25lckRhdGEgPSB3ZHlyU3RvcmUub3B0aW9ucy5nZXRBZGRpdGlvbmFsT3duZXJEYXRhKGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgd2R5clN0b3JlLm93bmVyRGF0YU1hcC5zZXQoZWxlbWVudC5wcm9wcywge1xuICAgICAgICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICBwcm9wczogT3duZXJJbnN0YW5jZS5wZW5kaW5nUHJvcHMsXG4gICAgICAgIHN0YXRlOiBPd25lckluc3RhbmNlLnN0YXRlTm9kZSA/IE93bmVySW5zdGFuY2Uuc3RhdGVOb2RlLnN0YXRlIDogbnVsbCxcbiAgICAgICAgaG9va3M6IHdkeXJTdG9yZS5ob29rc1BlclJlbmRlcixcbiAgICAgICAgYWRkaXRpb25hbE93bmVyRGF0YTogYWRkaXRpb25hbE93bmVyRGF0YVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlc2V0SG9va3NQZXJSZW5kZXJJZk5lZWRlZCgpIHtcbiAgICAvLyBJbnRlcmNlcHQgYXNzaWdubWVudHMgdG8gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCB0byByZXNldCBob29rc1BlclJlbmRlclxuICAgIHZhciBjdXJyZW50T3duZXIgPSBudWxsO1xuICAgIGlmICh3ZHlyU3RvcmUuUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3ZHlyU3RvcmUuUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuUmVhY3RDdXJyZW50T3duZXIsICdjdXJyZW50Jywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudE93bmVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgIGN1cnJlbnRPd25lciA9IHZhbHVlO1xuICAgICAgICAgIHdkeXJTdG9yZS5ob29rc1BlclJlbmRlciA9IFtdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJhY2tIb29rc0lmTmVlZGVkKCkge1xuICAgIHZhciBob29rc1N1cHBvcnRlZCA9ICEhd2R5clN0b3JlLlJlYWN0LnVzZVN0YXRlO1xuICAgIGlmICh3ZHlyU3RvcmUub3B0aW9ucy50cmFja0hvb2tzICYmIGhvb2tzU3VwcG9ydGVkKSB7XG4gICAgICB2YXIgbmF0aXZlSG9va3MgPSBPYmplY3QuZW50cmllcyhob29rc0NvbmZpZykubWFwKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgICAgICB2YXIgX3JlZjUgPSBfc2xpY2VkVG9BcnJheShfcmVmNCwgMiksXG4gICAgICAgICAgaG9va05hbWUgPSBfcmVmNVswXSxcbiAgICAgICAgICBob29rVHJhY2tpbmdDb25maWcgPSBfcmVmNVsxXTtcbiAgICAgICAgcmV0dXJuIFt3ZHlyU3RvcmUuUmVhY3QsIGhvb2tOYW1lLCBob29rVHJhY2tpbmdDb25maWddO1xuICAgICAgfSk7XG4gICAgICB2YXIgaG9va3NUb1RyYWNrID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShuYXRpdmVIb29rcyksIF90b0NvbnN1bWFibGVBcnJheSh3ZHlyU3RvcmUub3B0aW9ucy50cmFja0V4dHJhSG9va3MpKTtcbiAgICAgIGhvb2tzVG9UcmFjay5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmNikge1xuICAgICAgICB2YXIgX3JlZjcgPSBfc2xpY2VkVG9BcnJheShfcmVmNiwgMyksXG4gICAgICAgICAgaG9va1BhcmVudCA9IF9yZWY3WzBdLFxuICAgICAgICAgIGhvb2tOYW1lID0gX3JlZjdbMV0sXG4gICAgICAgICAgX3JlZjckID0gX3JlZjdbMl0sXG4gICAgICAgICAgaG9va1RyYWNraW5nQ29uZmlnID0gX3JlZjckID09PSB2b2lkIDAgPyB7fSA6IF9yZWY3JDtcbiAgICAgICAgdmFyIG9yaWdpbmFsSG9vayA9IGhvb2tQYXJlbnRbaG9va05hbWVdO1xuICAgICAgICB2YXIgbmV3SG9va05hbWUgPSBob29rTmFtZVswXS50b1VwcGVyQ2FzZSgpICsgaG9va05hbWUuc2xpY2UoMSk7XG4gICAgICAgIHZhciBuZXdIb29rID0gZnVuY3Rpb24gV2h5RGlkWW91UmVuZGVyUmVXcml0dGVuSG9vaygpIHtcbiAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBob29rUmVzdWx0ID0gb3JpZ2luYWxIb29rLmNhbGwuYXBwbHkob3JpZ2luYWxIb29rLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICB2YXIgZGVwZW5kZW5jaWVzUGF0aCA9IGhvb2tUcmFja2luZ0NvbmZpZy5kZXBlbmRlbmNpZXNQYXRoLFxuICAgICAgICAgICAgZG9udFJlcG9ydCA9IGhvb2tUcmFja2luZ0NvbmZpZy5kb250UmVwb3J0O1xuICAgICAgICAgIGlmIChkZXBlbmRlbmNpZXNQYXRoICYmIGxvZGFzaC5pc0Z1bmN0aW9uKGhvb2tSZXN1bHQpKSB7XG4gICAgICAgICAgICBkZXBlbmRlbmNpZXNNYXAuc2V0KGhvb2tSZXN1bHQsIHtcbiAgICAgICAgICAgICAgaG9va05hbWU6IGhvb2tOYW1lLFxuICAgICAgICAgICAgICBkZXBzOiBsb2Rhc2guZ2V0KGFyZ3MsIGRlcGVuZGVuY2llc1BhdGgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkb250UmVwb3J0KSB7XG4gICAgICAgICAgICB0cmFja0hvb2tDaGFuZ2VzKGhvb2tOYW1lLCBob29rVHJhY2tpbmdDb25maWcsIGhvb2tSZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaG9va1Jlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld0hvb2ssICduYW1lJywge1xuICAgICAgICAgIHZhbHVlOiBuZXdIb29rTmFtZSxcbiAgICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24obmV3SG9vaywge1xuICAgICAgICAgIG9yaWdpbmFsSG9vazogb3JpZ2luYWxIb29rXG4gICAgICAgIH0pO1xuICAgICAgICBob29rUGFyZW50W2hvb2tOYW1lXSA9IG5ld0hvb2s7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0V0RZUlR5cGUob3JpZ1R5cGUpIHtcbiAgICB2YXIgaXNTaG91bGRUcmFjayA9IGdldElzU3VwcG9ydGVkQ29tcG9uZW50VHlwZShvcmlnVHlwZSkgJiYgc2hvdWxkVHJhY2sob3JpZ1R5cGUsIHtcbiAgICAgIGlzSG9va0NoYW5nZTogZmFsc2VcbiAgICB9KTtcbiAgICBpZiAoIWlzU2hvdWxkVHJhY2spIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgZGlzcGxheU5hbWUgPSBvcmlnVHlwZSAmJiBvcmlnVHlwZS53aHlEaWRZb3VSZW5kZXIgJiYgb3JpZ1R5cGUud2h5RGlkWW91UmVuZGVyLmN1c3RvbU5hbWUgfHwgZ2V0RGlzcGxheU5hbWUob3JpZ1R5cGUpO1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSBnZXREZWZhdWx0UHJvcHMob3JpZ1R5cGUpO1xuICAgIHZhciBXRFlSUGF0Y2hlZENvbXBvbmVudCA9IGdldFBhdGNoZWRDb21wb25lbnQob3JpZ1R5cGUsIHtcbiAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgIGRlZmF1bHRQcm9wczogZGVmYXVsdFByb3BzXG4gICAgfSk7XG4gICAgcmV0dXJuIFdEWVJQYXRjaGVkQ29tcG9uZW50O1xuICB9XG4gIGZ1bmN0aW9uIHdoeURpZFlvdVJlbmRlcihSZWFjdCwgdXNlck9wdGlvbnMpIHtcbiAgICBpZiAoUmVhY3QuX19JU19XRFlSX18pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgUmVhY3QuX19JU19XRFlSX18gPSB0cnVlO1xuICAgIE9iamVjdC5hc3NpZ24od2R5clN0b3JlLCB7XG4gICAgICBSZWFjdDogUmVhY3QsXG4gICAgICBvcHRpb25zOiBub3JtYWxpemVPcHRpb25zKHVzZXJPcHRpb25zKSxcbiAgICAgIG9yaWdDcmVhdGVFbGVtZW50OiBSZWFjdC5jcmVhdGVFbGVtZW50LFxuICAgICAgb3JpZ0NyZWF0ZUZhY3Rvcnk6IFJlYWN0LmNyZWF0ZUZhY3RvcnksXG4gICAgICBvcmlnQ2xvbmVFbGVtZW50OiBSZWFjdC5jbG9uZUVsZW1lbnQsXG4gICAgICBjb21wb25lbnRzTWFwOiBuZXcgV2Vha01hcCgpXG4gICAgfSk7XG4gICAgcmVzZXRIb29rc1BlclJlbmRlcklmTmVlZGVkKCk7XG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChvcmlnVHlwZSkge1xuICAgICAgdmFyIFdEWVJUeXBlID0gZ2V0V0RZUlR5cGUob3JpZ1R5cGUpO1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgcmVzdFtfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cbiAgICAgIGlmIChXRFlSVHlwZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gd2R5clN0b3JlLm9yaWdDcmVhdGVFbGVtZW50LmFwcGx5KFJlYWN0LCBbV0RZUlR5cGVdLmNvbmNhdChyZXN0KSk7XG4gICAgICAgICAgaWYgKHdkeXJTdG9yZS5vcHRpb25zLmxvZ093bmVyUmVhc29ucykge1xuICAgICAgICAgICAgc3RvcmVPd25lckRhdGEoZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgd2R5clN0b3JlLm9wdGlvbnMuY29uc29sZUxvZygnd2h5RGlkWW91UmVuZGVyIGVycm9yLiBQbGVhc2UgZmlsZSBhIGJ1ZyBhdCBodHRwczovL2dpdGh1Yi5jb20vd2VsbGRvbmUtc29mdHdhcmUvd2h5LWRpZC15b3UtcmVuZGVyL2lzc3Vlcy4nLCB7XG4gICAgICAgICAgICBlcnJvckluZm86IHtcbiAgICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVPckNvbXBvbmVudDogb3JpZ1R5cGUsXG4gICAgICAgICAgICAgIHJlc3Q6IHJlc3QsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IHdkeXJTdG9yZS5vcHRpb25zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB3ZHlyU3RvcmUub3JpZ0NyZWF0ZUVsZW1lbnQuYXBwbHkoUmVhY3QsIFtvcmlnVHlwZV0uY29uY2F0KHJlc3QpKTtcbiAgICB9O1xuICAgIE9iamVjdC5hc3NpZ24oUmVhY3QuY3JlYXRlRWxlbWVudCwgd2R5clN0b3JlLm9yaWdDcmVhdGVFbGVtZW50KTtcbiAgICBSZWFjdC5jcmVhdGVGYWN0b3J5ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHZhciBmYWN0b3J5ID0gUmVhY3QuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAgICAgZmFjdG9yeS50eXBlID0gdHlwZTtcbiAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgIH07XG4gICAgT2JqZWN0LmFzc2lnbihSZWFjdC5jcmVhdGVGYWN0b3J5LCB3ZHlyU3RvcmUub3JpZ0NyZWF0ZUZhY3RvcnkpO1xuICAgIFJlYWN0LmNsb25lRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG4gICAgICB2YXIgZWxlbWVudCA9IHdkeXJTdG9yZS5vcmlnQ2xvbmVFbGVtZW50LmFwcGx5KFJlYWN0LCBhcmdzKTtcbiAgICAgIGlmICh3ZHlyU3RvcmUub3B0aW9ucy5sb2dPd25lclJlYXNvbnMpIHtcbiAgICAgICAgc3RvcmVPd25lckRhdGEoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuICAgIE9iamVjdC5hc3NpZ24oUmVhY3QuY2xvbmVFbGVtZW50LCB3ZHlyU3RvcmUub3JpZ0Nsb25lRWxlbWVudCk7XG4gICAgdHJhY2tIb29rc0lmTmVlZGVkKCk7XG4gICAgUmVhY3QuX19SRVZFUlRfV0hZX0RJRF9ZT1VfUkVOREVSX18gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBPYmplY3QuYXNzaWduKFJlYWN0LCB7XG4gICAgICAgIGNyZWF0ZUVsZW1lbnQ6IHdkeXJTdG9yZS5vcmlnQ3JlYXRlRWxlbWVudCxcbiAgICAgICAgY3JlYXRlRmFjdG9yeTogd2R5clN0b3JlLm9yaWdDcmVhdGVGYWN0b3J5LFxuICAgICAgICBjbG9uZUVsZW1lbnQ6IHdkeXJTdG9yZS5vcmlnQ2xvbmVFbGVtZW50XG4gICAgICB9KTtcbiAgICAgIHdkeXJTdG9yZS5jb21wb25lbnRzTWFwID0gbnVsbDtcbiAgICAgIHZhciBob29rc1RvUmV2ZXJ0ID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShPYmplY3Qua2V5cyhob29rc0NvbmZpZykubWFwKGZ1bmN0aW9uIChob29rTmFtZSkge1xuICAgICAgICByZXR1cm4gW1JlYWN0LCBob29rTmFtZV07XG4gICAgICB9KSksIF90b0NvbnN1bWFibGVBcnJheSh3ZHlyU3RvcmUub3B0aW9ucy50cmFja0V4dHJhSG9va3MpKTtcbiAgICAgIGhvb2tzVG9SZXZlcnQuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjgpIHtcbiAgICAgICAgdmFyIF9yZWY5ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjgsIDIpLFxuICAgICAgICAgIGhvb2tQYXJlbnQgPSBfcmVmOVswXSxcbiAgICAgICAgICBob29rTmFtZSA9IF9yZWY5WzFdO1xuICAgICAgICBpZiAoaG9va1BhcmVudFtob29rTmFtZV0ub3JpZ2luYWxIb29rKSB7XG4gICAgICAgICAgaG9va1BhcmVudFtob29rTmFtZV0gPSBob29rUGFyZW50W2hvb2tOYW1lXS5vcmlnaW5hbEhvb2s7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIFJlYWN0Ll9fUkVWRVJUX1dIWV9ESURfWU9VX1JFTkRFUl9fO1xuICAgICAgZGVsZXRlIFJlYWN0Ll9fSVNfV0RZUl9fO1xuICAgIH07XG4gICAgcmV0dXJuIFJlYWN0O1xuICB9XG5cbiAgd2h5RGlkWW91UmVuZGVyLmRlZmF1bHROb3RpZmllciA9IGRlZmF1bHROb3RpZmllcjtcbiAgd2h5RGlkWW91UmVuZGVyLndkeXJTdG9yZSA9IHdkeXJTdG9yZTtcbiAgd2h5RGlkWW91UmVuZGVyLnN0b3JlT3duZXJEYXRhID0gc3RvcmVPd25lckRhdGE7XG4gIHdoeURpZFlvdVJlbmRlci5nZXRXRFlSVHlwZSA9IGdldFdEWVJUeXBlO1xuICBPYmplY3QuYXNzaWduKHdoeURpZFlvdVJlbmRlciwgUmVhY3RfX25hbWVzcGFjZSk7XG5cbiAgcmV0dXJuIHdoeURpZFlvdVJlbmRlcjtcblxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2h5RGlkWW91UmVuZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@welldone-software/why-did-you-render/dist/whyDidYouRender.js\n");

/***/ })

};
;